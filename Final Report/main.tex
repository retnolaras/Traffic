\documentclass[11pt]{article}
\usepackage[a4paper,pdftex]{geometry}
\usepackage[english]{babel}
\usepackage{xcolor,enumitem} 
\usepackage{graphicx}
\usepackage{array} % for m[{x cm} in tables
\usepackage[lofdepth,lotdepth]{subfig}
\usepackage{colortbl}
\usepackage{float}
\usepackage[listings]{listings}
\usepackage{tabu}
\usepackage{longtable}

%--- for subsubsubsection
\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
%---

\graphicspath{{Images/}} 

\begin{document}
	\begin{titlepage}
	\center
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} 

        {\huge \bfseries Final Report}\\[0.4cm]
        	\ Team Keep It Clean
        
        {\large \today}\\[10cm] 
        
        \begin{minipage}{0.4\textwidth}
        		\emph{Authors:}\\
        			1474524/1	Retno Larasati\\
                    1581767/1	Ian Galna Johnson\\	
                    1579212/1	Thi Thanh Huong Ngo\\
                    1557762/1	Daniel Arturo Mendoza Hernandez\\
                    1530247/1	Abdelrahman Hamdy Hassan\\
        \end{minipage}

\end{titlepage}
\tableofcontents
\listoffigures
\listoftables
\newpage
	
\section{Introduction}
The project aims to develop software for a Traffic Simulator. The team was provided a brief set of general guidelines for their task, with a focus to \textit{'develop a Simulation Engine for testing traffic management policies'}. The team's first responsibility was to refine the general guidelines into a requirements definition for an engineering project. The team extensively researched related theory, sought out products developed professionally and academically, then developed a succinct set of detailed requirements, and finally designed, tested, and implemented the software. 

The team applied software engineering and project management techniques to organise and manage the project to meet and exceed the teams self assigned, stringent criteria in scope, quality, and imagination.\\

The project provided a great experience for the team to work in a real software development project. Overcoming the challenges of a typical project such as forming a new team, uncertainty, cultural and language barrier etc., the team has delivered the project successfully . We are also aware  of improvements that could be made to deliver a more robust, applicable piece of software in real life which we could not implement within the project constraints of time and resources.\\

This report will explain the project and it's delivery. There are seven sections. The first section is an introduction to the project, including background, objectives, and methodology. The second section will review literature and applications researched by the team in preparation. The third section explains the requirements and design of the software. The fourth section gives detail and reasoning for overall architecture and system components, including adjustments made throughout the development process, and testing done to verify and validate the software quality. The fifth section will provide readers with an understanding of how the group functioned as a team, the struggles and success, and the way work has been divided. The sixth section will give a critical evaluation, lesson learned, and possible future works. The appendix contains design artifacts (component design, class diagrams) and complete source code.

\subsection{Background}
Traffic simulation software plays an important role in defining effective traffic management policies. A traffic policy must be simulated and verified before it can be safely implemented in real life. Otherwise, it might harm road users’ safety and traffic efficiency. There are a lot of factors contributing to road accidents and traffic efficiency. The major factors include speed, traffic light timing and driver’s behaviours. For instance, in 2013, in the UK, 3,064 people were killed or seriously injured in crashes where speed was a factor.
Therefore, this project will simulate traffic management policies focusing on those 3 main factors ie. Speed limit; Traffic light timing; Driver's behaviours. The software will test different policies relating to these factors and analyse the traffic efficiency and safety in relation to traffic density, enforcement policy and driver's behaviours.

The analysis will be based on the average speed: average speed of vehicles in a session. This metric is to measure traffic efficiency and reliability.

In this report, we will explain how our traffic simulator program works and how it was implemented
	


\subsection{Objectives}
The project aims to develop a standalone Windows application to simulate traffic with different traffic policies and traffic density following UK Highway Code which is left-lane oriented. The application should allow users to simulate traffic in a single busy intersection or a larger area in town which includes multiple roads, lanes, junctions and traffic lights. Multiple types of vehicles and drivers' behaviours would be simulated. The report for each simulation session will be displayed at the end of each session to calculate metrics to evaluate traffic safety and efficiency for provided traffic scenario and policy.




\subsection{Scope}

Within the constraints of time and resources, the project's scope includes:
\begin{itemize}[noitemsep]
\item Controlled Map \& Road network: User can choose multiple map options to simulate
    \begin{itemize}[noitemsep]
	\item Junction: Simulate within a crossroad with 2 multi-lane and multi-direction roads. There is traffic light control at the crossroad.
	\item Town: Simulate within a larger town area which is a more complicated road network, including multiple roads, junctions, traffic lights. 
	\item Scalability: the program should allow adding more map options easily as required. 
	
	\end{itemize}

\item Vehicles: Simulate multiple types of vehicles, which include at least cars and ambulances (emergency vehicle) and at least three classes of driver’s behaviours (reckless, cautious, normal).

\item Policy: the application must support at least fixed control policy (traffic light timing, speed limit). It should be scalable to variable control policy. The application provides users options to define the policy to be simulated:
    \begin{itemize}
    \item Default: default policy, which has speed limit 60mph and traffic light timing of 10s for Green Light/Red Light/Amber Light
    \item Random: User can simulate the policy which is randomly regenated within the user-defined range
    \item Customised: User can manually enter value for the policy.
    \end{itemize}

\item Simulation engine: must test the policies with different types of vehicles and drivers' behaviours in different levels of traffic density.
\item Report: Must provide the statistics and calculates metrics  for each simulation session as above.
\end{itemize}

	
\subsection{Tools and Techniques}
\begin{itemize}


\item Development:
	\begin{itemize}[noitemsep]
	\item Technology: Java SE, JavaFX
	\item Unit Test: JUnit
	\item Source control: GitHub
	\end{itemize}
\item 	Collaboration:
	\begin{itemize}[noitemsep]
	\item Task Management: Trello
	\item Communication: Whatsapp
	\end{itemize}
\item  	Documentation:
	\begin{itemize}[noitemsep]
	\item Report: LaTeX
	\item Presentation: Powerpoint
	\end{itemize}
\end{itemize}
\subsection{Project Approach} 
    \subsubsection{Project Management: } The project is managed using Scrum methodology. 
    The project has 4  2-week iterations.
    The Scrum methodology gives us the following benefits:
    \begin{itemize}
    
    \item Enhanced team communication and collabration
    \item Quick learning cycle: realise the issues in requirements, designs and implementations early in the project. 
    \item Incremental project planning, delivery: effectively planning, monitor and control the project. It helps the team to evaluate project progress and address appropriate plan and actions to take the project back on track.
    \end{itemize}
    
	\subsubsection{Quality Management: } 
	\begin{itemize}
    \item Unit Test: Developers are responsible on developing JUnit test for their classes. Criteria: 80\% code coverage and 100\% test cases passed. 
    \item Integration Test and Regression Test: carried out at the end of each iteration. This is to ensure the integration code works as requirements and the new code does not break the existing features. 
    \item System Test: System Test is carried out in the last iteration. This is to ensure the software satisfy the system functional and non-functional requirements. Criteria: 80\% system requirement coverage
	\end{itemize}
	
	



\subsection{Project Outcome} \newline
\indent The project has achieved the following:

\begin{itemize}
\item Deliverables:
\begin{itemize}
    \item Requirement and Designs: User Case diagram, Class diagrams, Component diagrams 
    
    \item Software: The implemented software has achieved the following compared to the defined scope:
    \begin{itemize}
    \item Map: multiple map options as defined
    \item Road network: the road network design and implementation allows the scalability of the system.  
    \item Policy: allow users to multiple options to define the traffic policy as in the scope. 
    \item Vehicles: supports multiple types of vehicles and drivers' behaviours 
    \item Simulation engine: simulation different types of vehicles and drivers' behaviours in different map options and traffic policies, traffic scenarios. Though the simulation engine is  currently not yet implemented the speed limit policy.
    \item Report: the software provided report the each simulation session with metrics calculation as defined in the scope

    
    \end{itemize}
    \item Reports: Completed Initial Report and Final Report as required. 
\end{itemize}
\item Team members' skills development: 

\indent Team members experienced and improved the following skills during working on the project:
    Manage project using SCRUM methodology
    ; Tasks and time management
    ; Software design and Java development
    ; Unit testing using JUNIT
    ; Functional Testing
    ; Teamwork


\end{itemize}


\pagebreak
\section{Review}

Due to the layers of complexity inherent in real-life traffic systems; where a large number of agents and random variables interact within a dynamic environment has generated a lot of research interest in the area of traffic simulation. In \cite{Pursula}, Matti Pursula sets the theoretical framework for creating traffic simulators, defining them as programs that move objects overtime, taking into account a defined set of real life conditions. Pursula surveys different types of traffic simulators and identifies three types of simulated environments: microscopic, mesoscopic and macroscopic. The paper describes two main shifts in traffic simulators; the first is that they are more network focused 


One of the main motives for building microscopic traffic flow models is that to later integrate them to build macroscopic models. An example of a comprehensive microscopic traffic flow simulator is defined by Namekawa et al in \cite{NameUeda05Due to the prominence of purpose-specific simulators ,Namekawa's project aimed at building a general purpose database of road units, with information about width, road signs and general measurements. They code was designed so  that it would be reused and integrated to build a macroscopic traffic model.The model the road network with variable width proportions and different road divisions; such as sidelines and center lanes.


The concept of building smaller microscopic road unit and then building up to a network was something that was widely implemented in out project; we first implemented separate components such as a road, and an intersection and end up constructing a network map.

Other works focused on finding methods to improve the efficiency and effectiveness of the simulation, such as the research constructed by Sewall et al \cite{SewWilMer10}. Their paper modeled detailed 3D animations and visualization of traffic flows, fast method for efficient simulations of large-scale, real-world networks of traffic using continuum dynamics that maintains discrete vehicle information to display each vehicle.
Sewall approached this by adapting a single-lane continuum flow model to handle multi-lane traffic by introducing a novel model of lane changes and using a discrete visual representation for each vehicle and then compared the result with agent-based methods. 

Although this was not directly relevant to our project since we neither planned to implement lane changes and 3D modelling, but it made us more conscious about our decisions about flow and speed of the simulation.

\newpage
\section{Requirements and Design}
\subsection{Requirements}
\subsubsection{Configuration Requirements}
The following initial requirements come from the \textcolor{black}{\emph{Introductory Lecture Slides:}}\\
\begin{itemize}[noitemsep]
		\item All development of source code and documentation must be
		done through a public GitHub repository. 
		\item All documentation must be created with LATEX and handed in
		PDF format. 
		\item Use the standard article class with the default margins and
		11pt font and produce the PDF with pdflatex.
	\end{itemize}

\subsubsection{System Requirements}

    {\bf{Functional Requirements:}} \newline
    \begin{itemize}
        \item Use Case
        \begin{figure}[h]
        \includegraphics[width=16cm]{usecase} 
        \caption{Use Case} 
        \label{uc}
        \end{figure}
        \item Functional Requirements 
        \begin{itemize}
            \item Road Network:
                \begin{itemize}
                    \item Road: Must support multiple lanes and different traffic directions 
                    \item Junctions: Must support different types of intersections such as Crossroad, T junctions 
                    \item Traffic Light: traffic lights operate following  defined traffic policy for traffic light timing and state flow.
                    
                    
                    
                \end{itemize}
            \item Controlled Map: Allow users to choose map options to simulate:
                 \begin{itemize}[noitemsep]
	                    \item Junction: Simulate within a crossroad with 2 multi-lane and multi-direction roads. There is traffic light control at the crossroad.
	                    \item Town: Simulate within a larger town area which is a more complicated road network, including multiple roads, junctions, traffic lights. 
	                    \item Scalability: the program should allow adding more map options easily as required. 
                    	
	
    	\end{itemize}

        \item Vehicles: Multiple types of vehicles (Car, Bus, Emergency). 
            \begin{itemize}
                \item Car: drawn in BLUE on GUI
                \item Bus: drawn in RED on GUI
                \item Emergency: drawn in WHITE on GUI
            \end{itemize}
       
        
        \item Drivers' Behaviours: Reckless, Cautious, Normal:
        Reckless: drive faster than speed limit 20\%
        ;Cautious: drive slower than speed limit 20\%
        ;Normal: drive within +-10\% speed limit
        
        \item Policy: the application must support at least fixed control policy (traffic light timing, speed limit). It should be scalable to variable control policy. The application provides users options to define the policy to be simulated:
            \begin{itemize}
                \item Default: default policy, which has speed limit 60mph and traffic light timing of 5s for Green Light/Red Light/Amber Light
                \item Random: User can simulate the policy which is randomly regenerated within the user-defined range
                \item Customised: User can manually enter value for the policy.
            \end{itemize}

        \item Simulation engine: 
        \begin{itemize}
        
        \item Simulate different types of vehicles in user-defined simulation configurations:
            \begin{itemize}
            \item Defined Policy: Speed Limit and Traffic Lights Timing
            \item Traffic Density:
                \begin{itemize}
                \item HIGH: 50\% possibility there is a new vehicle generated in each simulation step
                 \item NORMAL: 30\% possibility there is a new vehicle generated in each simulation step
                
                \item LOW: 10\% possibility there is a new vehicle generated in each simulation step
                \end{itemize}
            \item Selected Map
            
            
            \end{itemize}
        
        \item Check the traffic context to make decision whether vehicles go straight, turn right, turn left, 3-point turn, increase speed, reduce speed or stop
        \end{itemize}
        
        
       
        \item Report: Must provide the statistics and calculates     metrics  for each simulation session. The metrics includes:
        \begin{itemize}
        \item Number of vehicles exited: The more vehicle exited the map, the more efficient the traffic is 
        \item Number of Crashes: the less number of crashes, the more traffic safety is
        
        \end{itemize}
        

    
    {\bf{Non-Functional Requirements:}} 
    \begin{itemize}
    \item Scalability: The design and implementation of the software must support the system scalability
    
    \item Performance: The simulation session must not halt due to low performance
    
    \item Reliability: Must achieve at least 90\% reliability. The system must not crash in all cases.
    
    \item Maintainability: Must follow Java best practices and coding standards. 
    
    \end{itemize}
   
      \subsubsection{Product Roadmap}
  From the system requirements, the product roadmap is as table below. The features are prioritised as MUST HAVE or SHOULD HAVE. MUST HAVE features must be delivered in the project whereas SHOULD HAVE features can be skipped if they do not fit within project time and resources  constraints.
  
      \begin{table}[H]
       
        \begin{tabular}{l|l}
             FEATURE & PRIORITY \\ \hline
             FT1- Road & MUST HAVE \\ \hline
             FT2- Lane & MUST HAVE \\ \hline
             FT3- Junction & MUST HAVE \\ \hline
             FT4- Traffic Light & MUST HAVE \\ \hline
             FT5- Network Manager & MUST HAVE \\ \hline
             FT6- Junction Map & MUST HAVE \\ \hline
             FT7- Town Map & SHOULD HAVE \\ \hline
             FT8- Generic Vehicle & MUST HAVE \\ \hline
             FT9- Car  & MUST HAVE \\ \hline
             FT10- Bus & MUST HAVE \\ \hline
             FT11- Emergency vehicle & MUST HAVE \\ \hline
             FT12- Drivers' behaviours & MUST HAVE \\ \hline
             FT13- Policy - fixed policy control  & MUST HAVE \\ \hline
             FT14- Policy- Variable policy control& SHOULD HAVE \\ \hline
             FT15- Session Manager  & MUST HAVE \\ \hline
             FT16- Simulation Engine- get traffic context & MUST HAVE \\ \hline
             FT17- Simulate- simulate vehicle moving straight & MUST HAVE \\ \hline
             FT18- Simulation Engine- simulate vehicle moving at junctions& MUST HAVE \\ \hline
             FT19- Simulation Engine- simulate vehicles at traffic lights & MUST HAVE \\ \hline
             FT20- Simulation Engine- simulate vehicles accelerate/decelerate & SHOULD HAVE \\ \hline
             FT21- Simulation Engine- simulate different traffic density & MUST HAVE \\ \hline
             FT22- Simulation Engine- simulate vehicles following traffic policy & MUST HAVE \\ \hline
             FT23- Simulation Engine- simulate different drivers' classes of behaviours & MUST HAVE \\ \hline
             FT24- GUI- GUI Layout & MUST HAVE \\ \hline
             FT25- GUI- User simulation settings & MUST HAVE \\ \hline
             FT26- GUI- Draw roads & MUST HAVE \\ \hline
             FT27- GUI - Draw junctions & MUST HAVE \\ \hline
             FT28- GUI- Draw traffic lights & MUST HAVE \\ \hline
             FT29- GUI- Draw vehicles & MUST HAVE \\ \hline
             FT30- GUI- Rendering & MUST HAVE \\ \hline
             
             
             
            
        \end{tabular}
        \caption{Product Roadmap}
        \label{tab:ROADMAP}
    \end{table}
    
    
    The iteration plan to deliver these features is as below:
    
    \begin{table}[H]
		
		\centering
		%\begin{tabular}{p{2.5cm}|p{4cm}|p{2.5cm}|p{2.5cm}|p{2cm}}
		\begin{tabular}{|m{3cm}|m{2cm}|m{2cm}|m{2cm}|m{3cm}|}
		\hline
		\multicolumn{5}{ |>{\columncolor[gray]{0.8}}c|}{\textbf{Iterations}} \\
		\hline
		\textbf{Iteration 0} & \textbf{Iteration 1} & \textbf{Iteration 2} & \textbf{Iteration 3}& \textbf{Iteration 4} \\ \hline
		
		Requirements & FT-1 & FT-3& FT-7 & System Testing\\ \hline
		
		System Architecture Design & FT-2 & FT-4 & FT-14 & System Bug Fixing\\ \hline
		
		Component Detailed Design & FT-8 & FT-5 & FT-18 & Final Report\\ \hline
		
		Initial Report & FT-9 & FT-6 & FT-19 & \\ \hline
		
		& FT-10 & FT-12 & FT-20 & \\ \hline
		
		& FT-11 & FT-26 & FT-23 \\ \hline
		
		& FT-13 & FT-17 & FT-27 &\\ \hline
		& FT-15 & FT-21 & FT-28 &\\ \hline
		& FT-24 & FT-22 && \\ \hline
		& FT-25 & FT-27&& \\ \hline
		&FT-26  & FT-28 && \\ \hline
		& FT-29 & FT-30 && \\ \hline
	
		\end{tabular}
		\caption{Iteration Plan}
		\label{table:iteration} 
		\end{table}
		
    
    \end{itemize}

  
	
\subsection{Design}
In this section we will discuss the design process for this project. after the first iteration, the group has settled for a design model with centralized computing unit. We decided to follow the Model-View-Controller design pattern ,discussed in detail in the next section. This was motivated by two reasons. The first was that we had made a design choice that cars wouldn't hold the ability to compute their path. The design principle we agreed on, is 'dumb cars and smart controllers'. Although we were aware that this would make the system a single agent system, we identified our program as one of mesocopic scope. That is balancing the focus on how the cars interact with map componenets and on how the traffic flows in the full map. 

We also strictly followed a modular approach; 'Car', 'bus'  and 'Emergency vehicles' are all subclasses of vehicle. left, right, center lanes are all subclasses of the Abstract Lane class.Road networks are made up of roads and junctions, Roads are made up of lanes, lanes of lane sections.

Our design and architecture also allows for extendability and scalability. Multiple lane mechanisms can easily be implemented. More driver behaviours can also be defined by editing the driver behaviour class and implementing the appropriate logic for each new behaviour in the Engine Although maps cannot be dynamically generated, but they are read by the engine dynamically.
 
 %insert class diagram
	
\section{Implementation} 
% st significant implementation details, focusing on those where unusual or detailed solutions were required. Quote code fragments where necessary, but remember that the full source code will be included as an appendix. Explain how you tested your software (e.g. unit testing) and the extent to which you tested it. If relevant to your project, explain performance issues and how you tackled them.
% This section of the report shall discusses the actual implementation of the traffic simulator system. The section will begin by discussing the initial prototypes that were developed and follow up with the technical discussion of the final implemented system.

This section of the report discusses about some of the implementation details that are deemed important to the project. The section is divided into different subsections.
\subsection{Overall Architecture}
This project was developed in Java. We decided to use Model-View-Controller(MVC) as the architectural pattern, and Singleton as the creational pattern. It is common to think of an application as having three main
layers such as presentation or user interface, application logic, and resource management. In MVC, the presentation
layer is split into controller and view. The most important separation is between presentation and
application logic. MVC encompasses more of the architecture of an application than is typical for a design pattern. Hence the term architectural pattern may be useful, or perhaps an aggregate design pattern.
    \begin{itemize}
    \item Model: The domain-specific representation of the information on which the application operates.
    The model is another name for the application logic layer (sometimes also called the
    domain layer). Application (or domain) logic adds meaning to raw data (e.g., calculating if today
    is the user’s birthday, or the totals, taxes and shipping charges for shopping cart items).
    Many applications use a persistent storage mechanism (such as a database) to store data.
    MVC does not specifically mention the resource management layer because it is understood
    to be underneath or encapsulated by the Model.
    \item View: Renders the model into a form suitable for interaction, typically a user interface
    element.
    \item Controller : Processes and responds to events, typically user actions, and may invoke changes
    on the model and view.
    \end{itemize}

The control flow in MVC generally works with the user interacts with the user interface in some way, a controller handles the input event from the user interface, and the controller accesses the model. In our application, (?)
Simulation Engine as the Controller, Vehicle, Policy and Road Network as the Model and the GUI as the View (?). 


\subsection{Development}
\subsubsection{GUI}
GUI component provides interface for user interactions (user settings, actions); visualises simulation on screen. GUI is implemented using JavaFX. The class diagram of GUI can be seen in Appendices Figure \ref{cdgui}.
    
The GUI consists of 3 main panes: Simulation Pane to visualise the simulation; User Settings Pane for user settings and interactions; Report Pane to display the simulation report. 

 \begin{figure}[H]
        \includegraphics[width=16cm]{GUIComponent} 
        \caption{GUI Components } 
        \label{gui}
    \end{figure}
    
    
    \paragraph{GUIComponent}
    This class is to layout UI components. GUIComponents extends BorderPane to set Left Pane for Simulation and Right Pane for User Settings Pane and Report Pane. 
    HBox, VBox and GridPane are used to layout UI controls horizontally, vertically or in a grid. 
    
    Simulation Pane has a Canvas object. Canvas is an image  on which can be drawn using its GraphicsContext graphics commands. This is a high level tool for doing drawing objects on screen. 
        
    The Canvas is set size (800x600) to ensure proper display on current screen resolutions. 
    
    
    
    As all policy settings are in integer, IntegerTextField  class which extends TextField was implemented to only allow integer number inputs.
    
    
    
    \paragraph{SimulationRenderer}
    
    This class implements IRenderer interface which is used in SimuationEngine to render simulation objects onto the GUI. render method is called on initialising the simulation and every simulation step to draw simulated map and vehicles
    
    A GraphicsContext object obtained from  Canvas.getGraphicsContext2D(). The simulation objects are drawn onto the canvas by using relevant operation commands of GraphicsContext.
    Simulation objects (roads, vehicles, junctions, traffic lights) be be drawn are obtained from Context of SimuationEngine. 
    
    \paragraph{InitScreen}
    This is the main form of the application, which displays GUIComponents; implements execution on user interactions and  interface with simulation engine to visualise the simulation. 
    
    
\pagebreak
\subsubsection{Road Network}

The Road Network is the package containing the source code necessary for building the environment that vehicles operate on. For a Traffic Simulation there must be a strictness to the environment, it must be constrained. Vehicles must be bound by the limitations of the roads they drive on, otherwise you are not simulating traffic but a free for all.

The inspiration for a road network comes from communications network infrastructure such as the Internet. In which Vehicles (packets) travel down Roads (edges/links), and switch between different roads by traversing through Junctions (nodes). As a data structure the Road network most closely represents a graph.

The Road Network for the Traffic Simulator had to be both more complex, but to maintain the lightweight nature of communications networks. It had to include complexity to maintain the required strictness, for example by only allowing a single vehicle to occupy a particular section of the road at a given time. But Lightweight in an attempt at avoiding the scalability problem suffered by other simulator projects \cite{website:SUMO-SimOfUrbMob}.


    \paragraph{LaneSection}
    
    The base unit of a Road Network is a LaneSection. As \cite{SewWilMer10} found, the most useful abstraction for a road is as a collection of 'area' units that a single Vehicle can occupy. In this case a LaneSection represents a two dimensional rectangle of area equal to an average car, or about two by three meters.
    
    To maintain simplicity and the Single Responsibility Principle \cite{website:Principles-of-OOD}, the LaneSection was abstracted as an Interface with the responsibility for indicating whether or not there is a Vehicle currently occupying the section and which direction a vehicle can move in from the Section. The AbstractLaneSeciton Java class is a step towards implementation, it includes default implementation for returning the occupant status of a section and for returning a true or false value for if a Vehicle can move off the Section in a particular direction. It is important to add implementation here, because these are features that are shared by all LaneSection implementations.
    
    It was intended to make the Road Network an Immutable data structure \cite{website:Oracle-Imm-Obj}, to maintain uniformity and reliability, and to prevent malicious users from interfering with simulations by altering data structures. This began with the LaneSection and continued to higher level parts of the data structure. The class fields for whether a vehicle can move out or a section are final private, setter methods are not provided for altering them and object creating is moved to a Factory class.
    
    The LaneFactory has the single responsibility of producing objects of the LaneSection implementations. A user passes a String value of the class name of the type of section they want to be produced. The Factory Pattern works well for this type of object creation. Not only to maintain immutability, but also to emphasize the principle of code hiding, and allow the implementations to be extended \cite{HeadFirstFreeman}.
    
    LaneSection names are UK centric. In the UK drivers drive on the left hand side, meaning that a LeftLane section would be closed on the left hand side, because the left hand side would be a sidewalk, verge, or some other non-drivable piece of land.
    
    There are several implementations for LaneSection, each representing some combination of directions that it is possible for a vehicle to move to.
    
    \begin{itemize}[noitemsep]
    \item LeftLane: Represents a Section that a vehicle can move forward or right.
    \item RightLane: Represents a Section that a vehicle can more forward or left.
    \item SingleLane: Represents a Section that a vehicle can move forward, backwards, left, or right.
    \item MiddleLane: Represents a Section that a vehicle can move forward, left, or right.
    \end{itemize}
    \paragraph{Road}
    
    The Road's themselves are some ordered structure that a vehicle can move along. They have the responsibility of providing an ordering for LaneSections, so that vehicles are able to know what Sections are in front of them and around them.
    
    The ListOfLists implementation provided for Road utilizes nested, parallel Lists as a way of representing multiple Lanes on a road. With each sub List representing a continuous lane within a road. This takes advantage of indexing provided by List data structures to allow Vehicles to know their own position by getting the index of the LaneSection they occupy, then looking ahead and around them by searching the parallel Lists with their own index as a starting point.
    
    Building upon the standard data structures provided by the Java Collections Library allowed the team to take advantage of many years of reliable development and save time from having to develop entire data structures from scratch.
    
    Creating and building Roads is a complex task that was removed from the Roads themselves to improve the adherence to SOLID principles. A RoadFactory class proves the logic for creating the Road implementations.
    
    Constructor based Dependency Injection is used to introduce a LaneFactory that the RoadFactory uses to populate the Road implementations with LaneSections.
    
    The RoadFactory is responsible for producing Road implementations, it does this by providing a produceRoad method. The method is kept as simple as possible, to create a road the user must only provide the type of road they want, the length they want their road to be, and the width they want their road to be. The complexity of creation is kept hidden from users by using private methods which deal with initialising and populating internal data structures with individual LaneSections.

    \paragraph{Junction}
    
    Junctions represent the nodes of the RoadNetwork graph. This is where there is the most difference between a Traffic simulator network and a communication network occurs. Because in a communication network node, the node can be a black box where packets can just appear at their entrance connection and reappear at their destination connection. However for a RoadNetwork the internals of a junction are a complicated and interesting feature, because different routes across a junction share internal positions within a junction and vehicles must have some recognition of how to behave with this potential for crossover.
    
    A Junction is modelled on the real world behaviour of vehicles at a junction and the information provided by road signs at junctions to drivers. The Junction is abstracted to a Junction interface, the interface provides a single public \textit{produceRoute} method. The method is intended to work in the same way as a driver approaching a real world Junction and planning their route across the Junction by reading road signs. The driver knows where they are when they enter the Junction, and where they want to be when they leave the Junction.
    
    To simulate this interesting behaviour, Junctions are represented as collections of LaneSections. Different routes through the Junction may share LaneSections. For example a vehicle going from left to right, would cross over with a vehicle going from top to bottom, if they were going over a cross road style junction.
    
    \begin{itemize}[noitemsep]
    \item PrePlannedRouteJuntion: The team provided a Junction implementation that has routes through it prePlanned on creation of each instance of the Junction. The Junction is created by providing the input and output roads that a Junction node must connect by passing them to a constructor. The Junction then creates an ordered collection of LaneSections that vehicles must follow to go from a certain entry point to a certain exit point. The Junction keeps track of these using a map structure. Where the key is a string concatenation of the coordinates of a vehicles entry and exit roads and the value is the list of LaneSections to be followed. This decision to pre determine routes removed a key complication from Junction logic. 
    \\~\\
    Although the time complexity of dynamically calculating a route for an individual vehicle whenever requested was not great. It is an algorithm that would have to be run over and over again for each vehicle. It was noted that in general real life vehicles will follow the same, or an almost identical route over a junction. By having routes generated on creation we reduced the burden on the processor, instead of having to generate similar routes over and over, it could generate one route just a single time which could then be reused by all vehicles.
    \\~\\
    One of the most difficult parts of the project was deciding how to model and create Junctions. In the end the team could not find a solution for dynamically creating linking nodes for roads of varying number and varying width. The decision was taken to hard code an algorithm implementation that solved the problem for a particular case, a varying number of Roads but each with only a single lane. However it did allow the team to prove the concept that a node could be modelled as an interesting feature, and that all the Traffic issues that come with cars crossing paths in real life could be modelled in code. It would be up to future developers or other teams to think smarter about dynamically generatin Junctions.
    
   
    \end{itemize}
    
    \paragraph{Traffic Light}
    Traffic Light is for a road at a junction. Each traffic light has a coordinates to place it on the map. There is  a timer in traffic light with the delay time set to traffic light timing for current traffic light state as defined in the policy. Therefore, the traffic light will change to the next state once the delay time of the timer expired. 
    
    
   
    ActionListener taskPerformer = new ActionListener() \{
   
        @Override \newline
        public void actionPerformed(ActionEvent e) \{ \newline
            nextState();  \newline
            timer.stop();\newline
            timer.setDelay((int) getDelay());\newline
            timer.restart();\newline
            
        \}\newline
        \};\newline
       
    }  
    
    
    
    
    
    
\subsubsection{Vehicle}
The Vehicle class is the component who represents all kinds of possible items that can move on a road. It was designed to be a class with generic functionality and common properties for all the vehicles types. Therefore the Vehicle class is the parent of the Car, Bus and Emergency classes.
There are some properties stored in a vehicle object. The ones that affect the simmulation are the ones related to updating the vehicle position (such as setAxom), the ones who sets and provides information of the vehicle on relation with the road (such as getNextRoadIndex), and the ones related to the driver behaviour (such as getBehaviour).
The Car, Bus and Emergency classes only differ with eachother in the way its constructor is implemented. The Emergency vehicle object has a default RECKLESS behaviour, but the Car and Bus objects behaviour is defined by probability rates.
Since we previously made mention of the drivers behavior, it is appropiate to review how the vehicle and behaviours are related.  The Enumerator Behaviour was created in order to represent different driver behaviours (RECKLESS, NORMAL and CAUTIOUS). The behaviours are assigned at the moment a new vehicle is generated, and only affect the vehicle speed assignation.
The car generation is handled by the \textbf{Vehicle Factory}.

\subsubsection{Vehicle Factory}
Having a way to represent vehicles in the simulation, it was needed an architectural solution to generarate many types of vehicles. The solution was to implement the Factory pattern to produce vehicles. The Vehicle Factory needs the vehicle type as input and produces a vehicle of that type.
This component is meant to be called by anyone how needs to produce an specific type of car. The generation logic does not contain any probability rate generation, thus this has to be implemented by the caller.

\subsubsection{Policy}        


This component is to define policy which consists of speed limit and traffic light timings policy settings.

As a single policy is applied to the whole simulation session, Policy is implemented as Singleton to ensure only one policy object is initiated and referenced among all other classes. 
 
Policy is constructed as a composite object of SpeedLimit and TrafficLightPolicy which allows to plug or unplug policy components easily (by adding or removing related policy component class). This is to enhance the maintainability and scalability

\subsubsection{Session Manager}
The Session Manager is the software component in charge of the session steps notifications. 
It was designed to be a monolithic component who launches notifications to any other when an arbitrary time period has passed, we will refer to this time as step. In order to accomplish the most appropriate design patterns to use are the Singleton and the Observer pattern.
The Session Manager component is divided into two parts. One is the Session.java and the SessionManager.java.

The first file has the class who represents the actual object who keeps track when a step has passed. It contains the thread safe mechanisms to increase and decrease the step size, so an external component may modify the size when convenient, allowing to speed up or slow down the beating of steps. It also contains a condition who allows an external component to pause the beating. The Session class inherits from the Java API class Observer. This means it has the pattern within ready to be used, therefore anyone could subscribe and start listening the Session notifications (the steps). For all the previous reasons, a Session object is meant to be run in its own thread, therefore it implements the Runnable interface.

The second file is the actual Session Manager. It works as the only entry point to any component who wants to know about the session steps. In order to ensure this, it follows the Singleton pattern. The Session Manager is the only object who knows about the Session, this means it is the only one able to create an instance of a Session thread and subscribe to it. The Session Manager exposes the Session API in a thread safe manner when needed. Whenever a components ask the Session Manager to start a Session, it launches a new Session thread if there is none already running. When a session is stopped, the Session Manager interrupts the Session thread safely. The Session Manager class inherits from the Java API class Observer, therefore allows to the components to listen notifications from the Session thread through it. The class diagram for Session Manager can be seen in Appendices \ref{subfig:cd3}.

\subsubsection{Simulator Engine}

The Simulator Engine acts as the control unit of our simulator program; since both the cars and the roads lack autonomy and agency, the simulator engine performs all the necessary calculations and makes decisions for car movements. The simulator engine consists of three main sub-components:
\begin{itemize}

\item \textbf{Simulation Engine} is the engine that controls the entire system and simulation, responsible for making decisions on behalf of the vehicles.
\item \textbf{Context} keeps lists for all needed information, as well as translates the relative positions communicated by the engine to absolute coordinates in order to be drawn.
\item \textbf{Simulation  Data} is the class for collecting all the data during the simulation iteration for analysis. This data includes the number of vehicles, the number of vehicle that succeeded to arrived at the their destination, average speed from all the vehicles, and prospective traffic estimation. The detail calculation method for the traffic estimation will be discuss in \ref{rte}.

\end{itemize}


\begin{figure}[H]
    \centering
    \includegraphics[scale=.2]{flowchart}
    \caption{Simulator Engine Algorithm flow chart}
    \label{flow chart}
\end{figure}        
        
The \textbf{Simulation Engine } is the main controller class that includes the core logic needed for simulation. The simulation engine utilizes the contextual lists kept by the context class. These lists include a list of active cars, their positions, junction to road mappings and traffic light to road mappings. The simulator engine uses a relative positioning system, where it references a car's position in terms of the road and lane section index it exists on, rather than using the absolute coordinate. This abstracts the simulation logic and separates it from the GUI logic. With the existence of this comprehensive contextual data, the simulator engine can achieve an omniscient presence, overseeing all cars and their respective contexts. 

The simulator engine is also responsible for implementing the policy controls set by the user from the Gui. Car generation density, entry point activation, session-management controls and simulation speeds are included in the user policy. Once these policy controls are retrieved from the GUI, the simulator can begin its simulation algorithm.

As shown in the flow chart in figure \ref{flow chart}, the simulation engine makes decisions for every car by carrying on a series of checks. First, the car checks if is the first iteration, automatically generating cars at the appropriate points of if it is. Then iterating on every car, it performs calculations, and informs  the context which in turn informs the GUI, so it can redraw the cars with the new coordinates. 

Then by asking the car and inferring from its position, it checks if its on a junction and applies the appropriate junction logic. The junction produces a path and a path is stored inside the car for the duration of its trip on the junction. If not on a junction, and the car is not nearing the end of the road it's on, it can move according to its speed as long as there are no cars ahead of it. The Engine defines a lookAhead function by which it can query a road and know whether or not the next x lane sections are occupied or free. The lookAhead of every car is defined by the driver behaviour inherent in every car object. If a car reaches the end of the road, it can go into one of three states. The first is  if there's a traffic light that is red, the car stops. The second is if the traffic light is green or there's no traffic light, car checks the existence of a junction, asks for a path on the junction and makes sure that the next position on the junction is empty before moving. While the third case happens when a car reaches an exit point, at which it is dequed from the list of active cars and logged by the SimulationData class 


The \textbf{Context} is a class that is part of the simulation engine logic. It represents a layer in charge of the translation of relative coordinates of the vehicles to absolute coordinates in pixels. Additionally, it provides information such as the traffic light positions. Therefore, this class serves as an information provider related to items positioning on the screen map.
This translation is made within the move function, which determines the new position of a given car to a given new position relative to roads and lane segments. This function calculates and sets the new position in pixels within the vehicle object to be consulted by any other component later.
The Context is meant to be updated by the Simulation Engine at every step when a simulation is running, and to be consulted by the UI layer when needed.





\subsubsection{Road Traffic Estimation} \label{rte}
The methodology to calculate the road traffic estimation we derived from annual series of road traffic estimation that published by the Department for Transport. We simplified and did several adjustment to our simulation data to get the estimation number. Department of Transport uses manual traffic counts. this data then combined with information from a network of automatic traffic counter (ATCs) to calculate a series of annual average daily flows (AADF) for each count point. These daily flows then combined with road lengths to calculate the number of vehicle miles travelled each year by vehicle types, road category and region. In the document AADF major and minor road are separated as traffic volume is calculated differently for major and minor roads, however, for our calculation we use the simulation data. For every tick represent as 1/3 second, so then we multiply each session duration with 86400 (number of second per day) to simulate 24 hours traffic. 
To convert the AADFs into traffic volume we multiply AADF with the link length, we then multiply it by the number of days in the year (365) to get an annual total. Link length is the total length of the network road link in km. For each lane section that we have, we decided that it will represent 3 meter in real life. Therefore, the link length calculate that from the number of lane section in the map and we multiply it by 0.003 km. 

The original formula for the estimation calculation from \cite{website:GovUk} is,
\begin{equation}
Traffic_{CP} = AADF_{CP} \times Lengthlink \times 365 
\end{equation}
and the adopted formula for the estimation calculation is,
\begin{equation}
Traffic Estimation = (No. of ticks \times 0.33 \times 86400) \times (No. of lanes \times 0.003) \times 365 
\end{equation}

\end{itemize}.

\subsection{Testing} 
%Explain how you tested your software (e.g. unit testing) and the extent to which you tested it. If relevant to your project, explain performance issues and how you tackled them.

Due to the agile nature of development and the modular nature of our design, the team has implemented multiple component and integration tests throughout the development process. As pointed out earlier, JUNIT frame work was used for unit testing. Table \ref{table:JUnitTestingTable} contains a list of all the Junit tests that exist in the test package of our project. The team has also carried out blackbox functional tests, as illustrated in table \ref{table:FunctionalTestingTable}. Additionally, we have implemented on-demand mutant testing.
\begin{center}
	\begin{table}[H]
	\begin{tabular}{|m{7cm}|m{7cm}|}
		 \hline
		\multicolumn{2}{ |>{\columncolor[gray]{0.8}}c|}{\textbf{JUnit Testing}} \\ \hline 
		 \centering \textbf{Class} & \textbf{Status}\\\hline
		 LaneSection & 
		 \includegraphics[width=7cm]{TestLaneSection}\\ \hline
		 Policy & \includegraphics[width=7cm]{TestPolicy}\\ \hline
		 Road & \includegraphics[width=7cm]{TestRoad}\\ \hline
		 SimulationData & \includegraphics[width=7cm]{TestSimulationData}\\ \hline
		 Vehicle & \includegraphics[width=7cm]{TestVehicle}\\ \hline
		 SessionManagerSPRT & \includegraphics[width=7cm]{SessionManagerSPRTest}\\ \hline
		 SessionManager & \includegraphics[width=7cm]{SessionManagerTest}\\ \hline
		
	\end{tabular}
	\caption{JUnit Test Execution Result}
		\label{table:JUnitTestingTable}
	\end{table}
\end{center}

For the system test, we based on the functionality that listed in Use Case (see Fig \ref{uc}).

\begin{center}
	\begin{table}[H]
	\begin{tabular}{|m{4cm}|m{6cm}|m{4cm}|}
		 \hline
		\multicolumn{3}{ |>{\columncolor[gray]{0.8}}c|}{\textbf{Functional Testing}} \\ \hline 
		 \centering
		 \textbf{Item to Test} & \textbf{Test Description} & \textbf{Status}\\\hline
		 Start Button & the simulation starts with the default setting & Passed \\  \hline
		 Terminate Button & the current state of simulation stops and terminated & Passed \\  \hline
		 Pause Button & the current state of simulation paused and can be resume afterwards & Passed \\  \hline
		 Resume Button & the paused simulation starts again from the previous state & Passed \\  \hline
		 Traffic Scenario & the simulation shows the traffic with correct traffic density that had chosen & Passed \\  \hline
		 Report & shows the results from the simulation latest state & Passed \\  \hline
		 Default Policy & runs the simulation with the default policy & Passed \\  \hline
		 Random Policy & runs the simulation with the random policy with defined minimum and maximum values & Passed \\  \hline
		 Customise Policy & runs the simulation with the customise policy with defined values & Passed \\  \hline
		
	\end{tabular}
	\caption{Functional Testing Table}
		\label{table:FunctionalTestingTable}
	\end{table}
\end{center}

We believe that although not entirely comprehensive, our testing had been sufficient and allowed for verifying that our product was functional, reliable and bug free. Our testing routine was frequent and most corner cases were considered.
	
\subsection{Development Adjustment}
Several functions that we planned to initially the didn't make due to time constraint, and since they were marked as law priority
\begin{enumerate}[noitemsep]
	\item Lane switching mechanisms have not been implemented
	\item Cars have constant speeds, no model for accelerations and deceleration were implemented.
	
	\item user given more control than initially planned such as users can adjust speed of the simulation, pause and resume the session,  as well as toggle entry points of vehicles.
\end{enumerate}


\pagebreak
\section{Team Work}
%Describe how you worked together, including the tools and processes you used to facilitate group work.
Our team organisation approach is to have a full-powered team. There is no decision-making manager role in the team. All project decisions are made with the participation of the whole team. 
The team objectives were clearly made. We set the principles of communication that  every member opens for questions and suggestions about their designs and implementation with the shared final  objective is to deliver the best software as we can. 
There have been a lot of events we had different opinions about designs, planning and implementations. We listened and tried to understand each other's opinion and patiently explained our own opinions. The whole team got involved to make decision if two members, for example, still could not reach to the same point. 

The team members also actively proposed to share workload from other members which had difficulties to complete on time.

There were a few times in the first iterations, some team members did not share the difficulties they were facing which made them unable to deliver as plan. This gave us less chance to work as a team to achieve the objectives. This  has been fixed in the later stages. 

We used Trello for the project management. Tasks in each iteration were broken down and picked by team members. At the end of each iteration we had retrospective meeting to review the last iteration, what we achieved, what we did not achieve and what we could have done better. We also planed for the next iteration. We created a list for each iteration, and wrote cards to put the task in. After the task is done, we move it to the DONE list, so we know which task that have not finished yet. The unfinished task then moved to the next iteration.

We used Whatsapp group for remote communication such as setup ad-hoc meeting, raising issues, asking questions etc.
 

We used sharelatex to edit our final report together. This collaboration latex editor enabled us to work together on Final Report better than what we did for our Initial Report. Sharelatex project also seamlessly integrates to our Github repository, helping us on document version control on Github. 

In our Initial Report, we  worked  separately on our assigned tasks and commit into Github. This method appeared to create a lot of conflict problems on Github when five people edited the same file at the same time. 
Sharelatex is a good tool to resolve this problem, since the group can now effortlessly collaborate in the same latex document. 

In initial project planning, we planed to have biweekly meeting, on Monday and Thursday. However,in later stages, to accelerate the project progress, we had meeting almost three or four times a week. The meetings were not just to update status and discuss issues but also to code together and quickly resolved any problems arose.



\subsection{Work Load Division:}

After doing the system component design, each team member is assigned to specific components and responsible on component detailed design, code and test. 

As a project is quite short and only 25\% our daily effort (ie. 2h/person/day) can be spent on this project, there is a risk not able to deliver on time if a team member becomes unavailable to work on the project such as sickness, urgent personal matters etc. Therefore, initially, we agreed to rotate components in the next iteration where possible to enable  depth and breadth in project understanding by all members, as well as allow a more flexible work distribution.

This strategy worked perfectly fine until the end of iteration 2. But from iteration 3, as deadline is approaching and more work to be done, we changed the strategy to stop rotating. The problem was that we spent a lot of time to discuss specific logic together, rather than used the time to develop the code. We also needed time to explain the logic that the previous programmer to the next programmer. 

In the first sprint,  we managed to do almost all the tasks that we listed before. Since it was  initiation stage, we mostly created different classes and objects that we thought we will need later. Files from policy (\textit{Policy, Speedlimit, Trafficlight}), GUI (\textit{UIComponent, drawUI}), road network (\textit{AbstractLaneSection, LaneFactory, LaneSection, LeftLane, MiddleLane, RightLane, SingleLane, ListOfListRoadImpl, Road, RoadFactory}), main (\textit{SessionManager, SimulatorEngine, TrafficSimulatorApplication}), and vehicle (\textit{Behaviour, Bus, Car, Direction, Emergency, Point, Vehicle, VehicleFactory, VehicleType}). We also created JUnit test files for unit testing such as \textit{testpolicy, testlanesection, sessionmanagersprtest, sessionmanagertest} and \textit{testvehicle}. 

In the end of iteration 1 we decided to change our designed by moving all the control from the engine to the vehicle. Therefore the vehicle itself would have the method to accelerate and decelerate, and the behaviour towards traffic light. The decision making will still be on simulation engine but the behaviour will be declared on the vehicle itself. 
For the iteration 2, we added new classes. Files from: policy (\textit{TrafficLightColour}), and roadnetwork (\textit{Junction, PrePlannedRouteJunction, TrafficLight}). We also developed the GUI class again from scratch, because in iteration 1 we still unsure about the detail design and how the data flow will work from the simulation engine to the UI component. We deleted \textit{UIComponent} and \textit{drawUI}, and added \textit{GUIComponent, InitScreen, integertextfield, irenderer, simulationrender, simulationsetting}. However, some of the tasks that we designated for this iteration could not be done and moved to the next sprint/iteration.  


\pagebreak
\section{Evaluation} 
\subsection{Lessons Learned and Challenges}

The team feels that participating in the project was a very productive experience. It allowed team members to gain a first hand understanding of the techniques, concepts, and practices that are common in professional Software Development. It also allowed team members to put into practice the engineering and computing skills they have been learning about, to complete a meaningful project. 

However there were several aspects which the team feels lessons could be learned from.
These can be broken down into two categories, Engineering lessons and Teamwork lessons.

\subsubsection{Engineering}

Engineering lessons involve things the team learned from the design, architecture, implementation, and testing of the code.

\begin{enumerate}
	
	\item \textbf{Overreach:}
	
	One of the most common lessons learned on computing projects is trying to do too much within a constrained period of time. It is understandable that, given a green field project, imaginative developers would be tempted to create expansive and open ended pieces of software. Unfortunately these projects tend to be bogged down with unnecessary components and a general sense of trying to do too much. This is a pitfall that the team is partially guilty of falling into. 
	
	At the beginning of the project, there was an optimistic feeling that the team could build a piece of traffic software comparable to commercially or academically available software. After a while of working on the project, it was decided that some of the \textit{would like to have} aspects should be dropped in favour of a more workable approach.
	
	The iterative Scrum style methodology \cite{website:Scrum-Alliance} the team adopted for development worked well in allowing us to respond to our changing goal. As after our first iteration we were able to see our overreach and realign our development goals. As our iterations progressed we were able to better understand our own abilities and limitations yet still create working piece of usable software at the end of each iteration.
	
	The main learning point of overreach is to set realistic constraints, but to allow for change. So that as your team creates software they are able to take advantage of new developments and progress not only the project but also their own abilities.
		
	\item \textbf{Vagueness of specification:}
	
	Similar to the problem of overreach is that of Vague Specification. Because the project had an open specification, it was the team's responsibility to whittle it down to a specific system. Initially the team was too vague about what they wanted their traffic simulator to be, too vague about the functional and non-functional requirements, too vague about what the team wanted to achieve with their product.
	
	The team believes that their Agile approach \cite{website:Agile-Manifesto} to development helped alleviate this issue. Because of the initial uncertainty over the purpose of the simulator, Agile helped them to refine their goals by emphasizing responsiveness over planning. Through successive iterations, the team was able to \textit{test the water} and get a feel for what purpose the project should achieve. To avoid \textit{scope creep} it was necessary for the team to be disciplined in remembering the agile principle of working software, and not introduce excess scope if \textit{'you ain't gonna need it'}.
	
	This wasn't a case of hacking a project together \textit{ad-hoc}. But a case of the team recognizing being in the situation of attempting a project with uncertain or undefined specification, and researching an established methodology for tackling these kinds of project. Then being pragmatic about adapting the methods to suit our needs.
	
	\item \textbf{Principles of Software Engineering}
	
	One of the things that helped the group overcome uncertainty in the project was to be faithful to a number of Software Engineering Principles that have become established within the Object Orientated software community. Following practices such as SOLID \cite{website:Principles-of-OOD} would allow the team to create a reusable, flexible, and robust code base, meaning that as the iterations went on the project would not need to be re-written with each slight change in desired outcome.
	
	Many of the early abstractions decided on by the team were clean and reusable. Such as the abstraction that a \textit{'Road'} is just an environment that a \textit{'Vehicle'} can be on, or that a traffic management \textit{'Policy'} is a rule or set of rules to be plugged into a simulation. These early abstractions allowed the team to be adaptive, in the beginning the team wanted an agent based Vehicle, however as the project developed they switched to a MVC based Vehicle. Because the Vehicle had a sound abstraction as simply an entity in an environment that moves from place to place, it was easily to substitute the \textit{'smart'} agent to a \textit{'dumb'} controlled object based vehicle, whilst allowing for future developers to extend the Vehicle abstraction into a more intelligent agent.
	
	Unfortunately, there were times in which the team was unable to avoid falling into bad habits and poor practices. A number of \textit{code smells} became apparent, for example the hard coding of algorithms for Junction behaviour which require large cyclomatic complexity. An excess of duplicated code. As well as the problem of \textit{contrived complexity}, by forcing design patterns into the code where perhaps there could be a simplified design. Some of the \textit{code smells} are recoverable through refactoring, code review, and extra documentation. The team is aware that these were practices they did not follow as well as they should.
	
	Another Agile principle followed by the team was that of Test Driven Development (TDD) \cite{website:Intro-TDD}. The team extensively used functional testing to verify the implementation of their work. By following a cycle of 
	
	Write Tests - Run Tests - \textbf {\textit{FAIL}} \rightarrow Write code - Run Tests - \textbf {\textit{PASS}}. 
	
	The team was able to continually verify that their implemented algorithm logic, and object design decisions were as intended by the coders.
	
	The team was able to use it's extensive test suites in regression testing, by making sure that historical tests still passed after integrating components from more recent iterations.
	
	It could be noted that TDD was not utilized as extensively as could have been. However, many Agile practitioners would suggest that these methodologies are simply guidelines to be followed to the extent that they contribute to the project, and that you shouldn't attempt to \textit{force} them into projects that they don't fit into. The team felt that this was the most suitable approach to take. To use testing to fulfil the needs of the project rather than to force testing into areas that the team didn't think suited it. Despite not following TDD explicitly for some areas of the simulator, the team still used testing to verify and check those areas for example Visual testing was used for verification of the visual elements.
	
	The team did not make full use of functional testing frameworks which could have assisted with difficult to test components. Using a Mock Object framework such as Mockito could have assisted with creating tests to verify visual elements that were difficult to test using just JUnit.
	
	The team also didn't fully utilize the static analysis domain of testing. Using whitebox testing as well as blackbox testing could have allowed the team to find bugs unfindable through blackbox testing alone.
	
	The main lesson learned in terms of TDD was not to use as many different types of testing as are available, but to use testing to the extent to which it supports development of the program.
	
	
\end{enumerate}
\subsubsection{Teamwork}

Teamwork lessons are those learned from the trial and error of working with others to complete a project that would be too big for each of us as individuals.

\begin{enumerate}
	
	\item \textbf{Communication}
	
	Establishing and maintaining communication was one of the biggest lessons learned over the course of the project. The team recognized it's importance from the start, however there is a feeling that we underestimated the required frequency and consistency of communication.
	
	One feature of scrum development is having a daily \textit{stand up} to discuss, what each team member has achieved, what they are looking to achieve on the forthcoming day, and what obstacles stand in their way. Due to commitments elsewhere, such as having to attend lectures and tutorials, jobs, and other university work, the team was unable to fully implement this aspect of Scrum. Many practitioners of Scrum feel that the daily stand up makes a strong contribution to the success of a project. Being able to keep up to date with the work of others and keep people aware of your own successes and struggles allows the team to gel together and work through more difficult parts of a project. Although the team held stand up progress meetings, they were perhaps not frequent enough to get the most out of them. They required team members to keep track of and to go over more than one days work so they took longer than desired, and ended up being more like traditional committee meetings often hindering rather than advancing the project.
	
	An important lesson the team learned from the problem with integrating established Scrum practices was the need to adapt traditional methods to suit the dynamics of each individual project. If the team could not communicate in person, they had to find ways of getting the same benefits by communicating remotely. The team made use of Whats App group messaging to answer the same \textit{'what I've done' - 'what I'm going to do - 'what stands in my way'} questions that would pop up at a stand up. Although remote communication might not be the most effective, but given the circumstantial limitation, the team believes that remote communications provide an adequate and sufficient compromise. 
	

	Another unique lesson that was learned by the team through participating in this project, was being able to find an unambiguous, concise way of saying things when communicating across cultural and language barriers. Seemingly intuitive terminology to one person, may be confusing and imprecise to another. For example, the English term \textit{'bi-weekly'} caused an issue early on because to one member of the group it meant 'every other week', but to another member of the group it meant 'twice a week'. This may seem like a trivial example, however it occurred on other occasions in more important matters, such as when creating documentation for code or when naming classes and functions. It can be difficult to recognise this as an issue until it's too late as it is perhaps embarrassing to ask someone for clarification of word that seems simple to the person using it. However the team was fortunate to learn this lesson early on, and decide to adopt a \textit{'no question is a silly question'} approach. Giving team members the confidence to ask questions helped greatly with overcoming language barriers and ambiguous language. The team feels this is an important lesson to learn, computing and technology is a global industry in which your colleagues will be from around the world. To get a first hand understanding of communicating with fellow professionals from a variety of backgrounds will allow team members to become more well rounded software engineers.
	
\pagebreak
\subsection{Future Work} 
%How the project could be extended
One of the most challenging aspects of any project is imagining what could be done, if the project was taken up by another team of engineers after the original team moves on to pastures new.
\\~\\
The team has discovered several paths that could be followed. Each of which would advance the base project into more specialized areas.
They can be broken down into two categories. Engineering improvements and Data gathering/simulation improvements.

\subsubsection{Engineering}
Engineering improvements involve changes to the system Software that could better utilize engineering principals and practices.

\subsubsection{Data}
Data based improvements involve giving the user greater control or access to the data generated by the simulation.\\

\begin{enumerate}
	
	\item \textbf{Parallelism:}
	\\
	
	Parallelism has emerged as an important concept in engineering, and more specifically in traffic simulation. Liu \cite{website:phy-ntnu-traffic-simulation} makes parallelism the key purpose of their project. Taking advantage of machines with multiple cores could allow for faster and more detailed simulations to be run. Perhaps by allowing vehicles or other objects within the simulation to be built as individual threads which would allow vehicles to act independently and concurrently within a map. Also by separating out the concerns of data gathering and simulation, if different threads were responsible for either aspect they could be more specialised.
	
	However it also requires more attention to detail when designing and writing code. As you must take care to synchronise shared data items to avoid pitfalls like deadlock and race conditions. This increased burden was one of the reasons the team decided against parallelization in their original project.
	
	The project's use of Java as it's primary programming language would allow future developers a convenient way into introducing parallelism. Java includes native, as well as third party, support for parallelism, such as the Fork/Join framework\cite{LeaForkJoin} as well as the new Java 8 Streams functionality\cite{website:Oracle-Java-8}, as well as native control libraries for concurrency controls.
	
	The modular approach the team took to designing the system architecture also facilitates the introduction of parallelism, because different modules could be parallelised independently.
	\\While the Test Driven Development approach would allow iterative introduction of parallelisation with the capacity to test if the new developments fit in with the accepted functionality tested in the original test suites.\\
	
	\item \textbf{External Libraries:}
	\\
	
	Another future improvement would be to include libraries and code from outside sources. The team decided early on that because one constraint of the project was for it to be \textit{the teams own work}, and because no credit would be received from using other's work, that the team would use as few external tools as possible, thus to avoid conflict. 
	
	Most notably, visualisation and data gathering and analysis tools could be used. Visualisation tools could improve the user experience by allowing a more immersive interaction with the simulation. Because of the team's Model-View-Controller approach to the architecture, and because the team followed software principles of separation of responsibilities, it would be easy for future developers to introduce other visualisation modules to the project.
	
	The visualisation provided by the TransModeler Project project \cite{website:caliper.com-transmodeler} is a good example of how improving visualisation is key to an enjoyable, productive, and useful piece of Traffic Simulation software.
	\\ Data gathering could be improved by using something like Log4j \cite{website:Apache-Log4j} to log and collect data from simulations. Data analysis could be improved by utilizing external libraries such as Apache Spark.
	
	The teams decision to use Java is key to the extensibility of the project. Java has a rich history of third party libraries being designed and built with 'free' software licenses, so that others can use them in their own work and avoid reinventing the wheel.
	
	The team's architectural design, which focuses on reusabilty, substitutability, and scalability would give future developers the opportunity to come in and introduce a wide variety of tools with very little code re-writing.\\
	
	\item \textbf{Distributed Road Network:}
	\\
	
	One of the original \textit{would like to have} aims of the project was to counter some of the scalability problems of other Traffic Simulation software \cite{SewWilMer10} by providing for a distributed road network. By allowing the simulation to scale to multiple machines would mean larger and more detailed simulations could be run. But at the same time keeping the ability for simulations to be run on a single machine, so that smaller simulations would not need to worry about consistency and distribution issues.
	
	Although the team decided that it would be detrimental to provided such functionality within the original project, due to time constraints and a limited number of iterations, and that it would be more productive to focus on the more fundamental aspects of Traffic Simulation software so that our imagined customers would have access to usable software as early as possible.
	
	However, because the team recognized the importance of overcoming the scalability problem they made it a goal to allow for future developers to introduce distributed deployment with as little complication as possible.
	
	The fundamental road network data structure kept the transitions between different roads and junctions as simple and lightweight as possible allowing those same transitions to be carried out over a network by introducing a transfer protocol to mimic the transition.\\
	
	\item \textbf{Agent Programming for Vehicle behaviour:}
	\\
	
	One of the key decisions made by the team was to focus on creating a Model-View-Controller architecture for the system. This, however, limited the scope for introducing independent \textit{agent based} behaviour for the vehicles being modelled.
	
	It was recognised that allowing for the introduction of independent agent behaviour could be crucial to future iterations of the project, if taken on by other development teams. As Traffic Simulation of greater complexity would require software agents to model the independent nature of vehicle users on a real road.
	
	For this reason, the team decided on an abstract design for \textit{vehicles}. Creating this abstraction would allow our implementation of vehicles to be swapped out for a more complex agent based implementation.\\
	
	\item \textbf{Machine Learning for Vehicle Behaviour and Data Analysis:}
	\\
	
	A further improvement to Vehicle behaviour could be found by utilizing machine learning.
	
	Again, because of the flexible approach the team took, it would be convenient for a future development team to take over and add machine learning to the vehicle behaviour. Also because of the well documented nature of the source code and the \textit{Clean Code} \cite{MartinRC08} approach the team took, a new team could understand the current state of the project and make improvements without first having to slog through and decipher the current state.
	
	As well as Vehicle behaviour, the Analytical side of the Traffic Simulator could be improved with machine learning tools.\\
	
	\item \textbf{User defined Maps:} 
	\\
	
	Due to iteration constraints, it was decided that the working product at the end of the final development cycle should only contain maps predefined by the team. This allowed the team to present a demonstration of a useful and working product.
	
	The team did however realise that the Traffic Simulators potential would be greatly diminished if users could not add and create their own maps. On further iterations, it would be possible and productive to create a feature for generating a users own map.
	
	Because of the evident usefulness of this feature, the team made efforts to allow integration to be a simple as possible. The intuitive way that maps are created as a data structure, and the convenient way that maps are translated and drawn by the visualisation component, mean that future development teams have an easier time of implementing user maps.\\
	
	
	\item \textbf{Integration with Third party APIs for Maps:} 
	\\
	
	Following on from user generated maps, a component that allows the Traffic Simulator to be integrated with pre existing map software could be very useful. If a user could select a section of Google Maps and have the features of that map parsed into a data structure usable by the Simulator. Users would have the ability to create and run simulations on existing road networks with greater simplicity than if they had to construct maps themselves.
	
	Combining a component for users to create and edit their own maps with a feature for extracting maps from pre existing map software would allow users to re engineer road networks, to simulate potential improvements to real life road systems.
	
\end{enumerate}

\pagebreak
\subsection{Peer Assessment}

	%In a simple table, allocate the 100 ‘points’ you are given to each team member. Valid values range from 0 to 100 inclusive. You may assign decimal values, but the entire points must add up to precisely 100. As stated at the beginning of the project, when awarding points to each member it would based on contribution, ...below is the grade table for each member totalling up to 100. 

For the purpose of peer assessment, the team has devised four criteria by which the team use to evaluate each individual's performance. The scale is from 0-5 for each criteria, in which 5 is the score for the highest performance.
 

\begin{itemize}
\item  \textbf{Punctuality/ Availability}
	\subitem Showing up for meetings and joint coding sessions on time, as well as submitting required work on time.
	Making oneself available for pair/group design, coding, and testing sessions.
	
	\item \textbf{Teamwork}
	
	\subitem Maintaining communication with the team throughout the process. Being open to questions about your design or implementation decisions.  Being a team player.
	
	\item \textbf{Innovation/ Pro-activity}
	\subitem Suggesting imaginative ideas, finding innovative solutions to the software decisions.
	
	\item \textbf{Quality}
	
	\subitem Delivering products with good quality. Quality is defined as: meeting functional and non-functional requirements; following best practices and coding standards. 
	Quality-oriented mindset is expected, where team members always attempt the best effort to deliver the best product. 
	

\end{itemize}
The peer assessment process provides the team members  peer feedback about their strength and areas of improvement regarding working in a project. This is a valuable source for our personal development. The peer assessment result is as below:

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}|p{1.8cm}|p{1.8cm}|p{1.8cm}|p{1.8cm}|p{1.8cm}}
         \textbf{Name} & \textbf{P/A} &  \textbf{Teamwork} & \textbf{I/P} & \textbf{Quality} &\textbf{Average}  \\ \hline
         Retno Larasati & 5 & 5 & 5 & 5   & 5           \\ \hline
         Ian Galna Johnson &5 & 5 & 5 & 5 & 5           \\ \hline
         Thi Thanh Huong Ngo & 5 & 5 & 5 & 5 & 5       \\ \hline   
         Daniel Arturo Mendoza Hernandez & 5 & 5 & 5 & 5 & 5  \\ \hline
         Abdelrahman Hamdy Hassan  & 5 & 5 & 5 & 5  & 5 \\ \hline
    \end{tabular}
    \caption{Peer Assessment}
    \label{tab:assessment}
\end{table}

\textbf{Final Score Distribution} \newline
All team members have worked their best in the project and brought valuable contribution to the project. Therefore, we decided to award each team member the same score distribution which is 20\% each. 

\begin{table}[H]
    \centering
    \begin{tabular}{l|r}
         \textbf{Name} & \textbf{Score Distribution}  \\ \hline
         Retno Larasati & 20\%           \\ \hline
         Ian Galna Johnson & 20\%           \\ \hline
         Thi Thanh Huong Ngo & 20\%        \\ \hline   
         Daniel Arturo Mendoza Hernandez & 20\%  \\ \hline
         Abdelrahman Hamdy Hassan  & 20\%  \\ \hline
         Total & 100\% \\
    \end{tabular}
    \caption{Final Score Distribution}
    \label{tab:finalscore}
\end{table}

	
\newpage


\bibliography{main}
\bibliographystyle{plain}


\newpage

\section{Appendices} % ALL THE EXTRA STUFF.

\subsection{Class Diagrams}
\begin{figure}[H]
\begin{tabular}{cc}
		\subfloat[User Diagram]{
		    \setlength{\fboxsep}{0pt}%
			\setlength{\fboxrule}{1pt}%
			\fbox{\includegraphics[width=6cm\linewidth]{Picture1}}
			\label{subfig:cd1}
		}&
		\subfloat[Class Diagram: Vehicle]{
		    \setlength{\fboxsep}{0pt}%
			\setlength{\fboxrule}{1pt}%
			\fbox{\includegraphics[width=6cm\linewidth]{Picture4}}
			\label{subfig:cd2}
		}\\
		\subfloat[Class Diagram:Session Manager]{
			\setlength{\fboxsep}{0pt}%
			\setlength{\fboxrule}{1pt}%
			\fbox{\includegraphics[width=6cm\linewidth]{Picture3}}
			\label{subfig:cd3}
		}&
		\subfloat[Class Diagram:GUI]{
			\setlength{\fboxsep}{0pt}%
			\setlength{\fboxrule}{1pt}%
			\fbox{\includegraphics[width=6cm]{Picture2}}
			\label{subfig:cd4}
		}\\
		\subfloat[Class Diagram:Road Network]{
			\setlength{\fboxsep}{0pt}%
			\setlength{\fboxrule}{1pt}%
			\fbox{\includegraphics[width=6cm\linewidth]{Picture5}}
			\label{subfig:cd5}
		}&
		\subfloat[Class Diagram:Policy]{
			\setlength{\fboxsep}{0pt}%
			\setlength{\fboxrule}{1pt}%
			\fbox{\includegraphics[width=6cm\linewidth]{Picture6}}
			\label{subfig:cd6}
		}
		\end{tabular}
		\caption[]{Planning Class Diagrams}
		\label{fig:Planning}
\end{figure}

\begin{figure}[H]
        \includegraphics[width=10cm]{GUI} 
        \centering
        \caption{Class Diagram GUI } 
        \label{cdgui}
\end{figure}

\begin{figure}[H]
        \includegraphics[width=12cm]{junction} 
        \centering
        \caption{Class Diagram Road Network: Junction} 
        \label{cdjunction}
\end{figure}

\begin{figure}[H]
        \includegraphics[width=12cm]{road} 
        \centering
        \caption{Class Diagram Road Network: Road} 
        \label{cdroad}
\end{figure}

\begin{figure}[H]
        \includegraphics[width=12cm]{laneSection} 
        \centering
        \caption{Class Diagram Road Network: Lane Section} 
        \label{cdlane}
\end{figure}

\begin{figure}[H]
        \includegraphics[width=12cm]{policy} 
        \centering
        \caption{Class Diagram Road Network: Policy} 
        \label{cdpolicy}
\end{figure}

\begin{figure}[H]
        \includegraphics[width=14cm]{vehicle} 
        \centering
        \caption{Class Diagram Vehicle} 
        \label{cdvehicle}
\end{figure}

\begin{figure}[H]
        \includegraphics[width=12cm]{session} 
        \centering
        \caption{Class Diagram Session Manager} 
        \label{cdsessionmanager}
\end{figure}

\begin{figure}[H]
        \includegraphics[width=14cm]{simulatorengine} 
        \centering
        \caption{Class Diagram Simulator Engine} 
        \label{cdsimulatorengine}
\end{figure}


\subsection{Live Application}
\begin{figure}[H]
        \includegraphics[width=12cm]{Test1}
        \centering
        \caption{Initial State}
        \label{fig:test1}
\end{figure}
\begin{figure}[H]
        \includegraphics[width=12cm]{Test2}
        \centering
        \caption{Start Simulation}
        \label{fig:test2}
\end{figure}

\begin{figure}[H]
        \includegraphics[width=12cm]{Test4}
        \centering
        \caption{Change the traffic density to High}
        \label{fig:test4}
\end{figure}
\begin{figure}[H]
        \includegraphics[width=12cm]{Test5}
        \centering
        \caption{High density traffic simulation}
        \label{fig:test5}
\end{figure}
\begin{figure}[H]
        \includegraphics[width=12cm]{Test6}
        \centering
        \caption{Change the traffic density to Low}
        \label{fig:test6}
\end{figure}
\begin{figure}[H]
        \includegraphics[width=12cm]{Test7}
        \centering
        \caption{Low density traffic simulation}
        \label{fig:test7}
\end{figure}
\begin{figure}[H]
        \includegraphics[width=12cm]{Test3}
        \centering
        \caption{Terminate Simulation}
        \label{fig:test3}
\end{figure}

\begin{figure}[H]
        \includegraphics[width=12cm]{Test8}
        \centering
        \caption{Map: Town}
        \label{fig:test8}
\end{figure}



\subsection{Git Log}
\begin{center}
\begin{longtabu}to \textwidth {|
     X[4,l]|
     X[3,c]|
     X[8,l]|}
    \hline
    \textbf{Author} & \textbf{Date} & \textbf{Message} \ \hline
retnolaras & 2016-01-24 & first commit \\ \hline
Daniel Mendoza & 2016-01-25 & Update README.md \\ \hline
retnolaras & 2016-01-28 & Initial Report \\ \hline
Daniel Mendoza & 2016-01-29 & Merge remote-tracking branch `origin/daniel-arturo-mendoza-patch-1' \\ \hline
Daniel Mendoza & 2016-01-29 & Session Manager \\ \hline
Daniel Mendoza & 2016-01-29 & Merge remote-tracking branch `retnolaras/master' \\ \hline
Daniel Mendoza & 2016-01-29 & Fixing Null pointers when starting and stopping the session. A new session object is now created every time a session starts. This session object is set to null when the session is stopped. Th garbage collector should handle it. \\ \hline
retnolaras & 2016-01-30 & Merge pull request \#1 from daniel-arturo-mendoza/master \\ \hline
igalna & 2016-02-01 & Initial Commit. \\ \hline
igalna & 2016-02-01 & Package renaming for improved readability \\ \hline
igalna & 2016-02-01 & kcl.keepitclean.test.roadnetwork \\ \hline
igalna & 2016-02-01 & remove .class files from changes \\ \hline
igalna & 2016-02-01 & .gitignore \\ \hline
igalna & 2016-02-01 & TestRoadNetwork \\ \hline
igalna & 2016-02-01 & gitignore \\ \hline
igalna & 2016-02-01 & removed .class files form the bin directory \\ \hline
igalna & 2016-02-01 & .gitignore \\ \hline
igalna & 2016-02-01 & added bin folder to gitignore \\ \hline
igalna & 2016-02-01 & Lane Section is the base object of a road network. \\ \hline
retnolaras & 2016-02-02 & new initial report \\ \hline
retnolaras & 2016-02-02 & section 1.3 and 1.4 \\ \hline
Daniel Mendoza & 2016-02-02 & Merge remote-tracking branch `retnolaras/master' \\ \hline
retnolaras & 2016-02-03 & Merge pull request \#2 from igalna/master \\ \hline
retnolaras & 2016-02-03 & section 1.1 \\ \hline
retnolaras & 2016-02-03 & coordinate and vehicle class \\ \hline
retnolaras & 2016-02-03 & etc \\ \hline
retnolaras & 2016-02-03 & Merge remote-tracking branch `origin/master' \\ \hline
Daniel Mendoza & 2016-02-03 & adding info tom management, technical and test approaches. \\ \hline
Daniel Mendoza & 2016-02-03 & Scrum \\ \hline
Daniel Mendoza & 2016-02-03 & Merge remote-tracking branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-02-03 & Merge pull request \#3 from daniel-arturo-mendoza/master \\ \hline
Daniel Mendoza & 2016-02-03 & Roles \\ \hline
Daniel Mendoza & 2016-02-03 & Merge branch `master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-02-03 & Technology and Quality \\ \hline
Daniel Mendoza & 2016-02-03 & Merge remote-tracking branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-02-04 & Merge pull request \#4 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
AbdoHassan1994 & 2016-02-04 & Create InitialReportGP.tex \\ \hline
retnolaras & 2016-02-04 & delete some stuff from 1.1 and 1.2 \\ \hline
Daniel Mendoza & 2016-02-04 & Merge remote-tracking branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-02-04 & summarize \\ \hline
retnolaras & 2016-02-04 & edit 1.1 \\ \hline
retnolaras & 2016-02-04 & Merge pull request \#6 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-02-04 & Revert ``delete some stuff from 1.1 and 1.2'' \\ \hline
retnolaras & 2016-02-04 & new \\ \hline
retnolaras & 2016-02-04 & Merge remote-tracking branch `origin/master' \\ \hline
AbdoHassan1994 & 2016-02-04 & Create InitialReportGP.tex \\ \hline
retnolaras & 2016-02-04 & ignore pdf file \\ \hline
AbdoHassan1994 & 2016-02-04 & Create InitialReportGP.tex \\ \hline
retnolaras & 2016-02-04 & Merge pull request \#7 from AbdoHassan1994/patch-1 \\ \hline
retnolaras & 2016-02-04 & remove table 1. \\ \hline
retnolaras & 2016-02-04 & remove table 1 and edit 1.3 \\ \hline
retnolaras & 2016-02-04 & merge stuff \\ \hline
igalna & 2016-02-04 & Updated Initial report with section relating to handling the peer assessment \\ \hline
igalna & 2016-02-04 & Initial report log files \\ \hline
retnolaras & 2016-02-05 & Merge pull request \#8 from igalna/master \\ \hline
retnolaras & 2016-02-05 & newest merge \\ \hline
Daniel Mendoza & 2016-02-05 & Merge remote-tracking branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-02-05 & Added the Conflict resolution section of the Initial Report Document \\ \hline
igalna & 2016-02-05 & .log file for Initialreport \\ \hline
retnolaras & 2016-02-06 & compacting the table \\ \hline
retnolaras & 2016-02-06 & - \\ \hline
retnolaras & 2016-02-06 & - \\ \hline
retnolaras & 2016-02-06 & Delete InitialReportGP.pdf \\ \hline
retnolaras & 2016-02-06 & Merge remote-tracking branch `origin/master' \\ \hline
retnolaras & 2016-02-06 & Merge branch `pr/5' \\ \hline
retnolaras & 2016-02-06 & Merge remote-tracking branch `origin/master' \\ \hline
retnolaras & 2016-02-06 & add conflict handling \\ \hline
retnolaras & 2016-02-08 & correcting typos \\ \hline
igalna & 2016-02-08 & Merge remote-tracking branch `upstream/master' \\ \hline
AbdoHassan1994 & 2016-02-08 & Merge remote-tracking branch `retnolaras/master' \\ \hline
AbdoHassan1994 & 2016-02-08 & summary \\ \hline
retnolaras & 2016-02-08 & Merge pull request \#10 from AbdoHassan1994/master \\ \hline
Daniel Mendoza & 2016-02-08 & adding comments 1 \\ \hline
Daniel Mendoza & 2016-02-08 & Merge remote-tracking branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-02-08 & Merge remote-tracking branch `upstream/master' \\ \hline
igalna & 2016-02-08 & updated local repo from master \\ \hline
retnolaras & 2016-02-08 & edited initial progress \\ \hline
rosiengo & 2016-02-08 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
retnolaras & 2016-02-08 & edited typo \\ \hline
Daniel Mendoza & 2016-02-08 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-02-08 & changed some terms \\ \hline
retnolaras & 2016-02-08 & Merge pull request \#11 from rosiengo/master \\ \hline
rosiengo & 2016-02-09 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
rosiengo & 2016-02-09 & policy \\ \hline
rosiengo & 2016-02-09 & policy test \\ \hline
AbdoHassan1994 & 2016-02-09 & Merge pull request \#1 from retnolaras/master \\ \hline
AbdoHassan1994 & 2016-02-09 & added sentences \\ \hline
retnolaras & 2016-02-09 & Merge pull request \#13 from AbdoHassan1994/master \\ \hline
rosiengo & 2016-02-10 & uml policy \\ \hline
rosiengo & 2016-02-10 & updated policy code \\ \hline
retnolaras & 2016-02-10 & Merge pull request \#12 from rosiengo/master \\ \hline
igalna & 2016-02-10 & Merge remote-tracking branch `upstream/master' \\ \hline
Daniel Mendoza & 2016-02-10 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
AbdoHassan1994 & 2016-02-15 & Merge remote-tracking branch `retnolaras/master' \\ \hline
rosiengo & 2016-02-15 & new policy \\ \hline
AbdoHassan1994 & 2016-02-15 & Create readme \\ \hline
igalna & 2016-02-15 & Rename of TestRoadNetwork to TestLaneSection \\ \hline
igalna & 2016-02-15 & TestLaneSection \\ \hline
AbdoHassan1994 & 2016-02-15 & add files \\ \hline
igalna & 2016-02-15 & AbstractLaneSection \\ \hline
igalna & 2016-02-15 & Concrete implementations of the different LaneSections \\ \hline
retnolaras & 2016-02-15 & Merge pull request \#14 from rosiengo/master \\ \hline
retnolaras & 2016-02-15 & Merge pull request \#15 from AbdoHassan1994/patch-2 \\ \hline
igalna & 2016-02-15 & LaneFactory class \\ \hline
Daniel Mendoza & 2016-02-15 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-02-15 & Merge remote-tracking branch `upstream/master' \\ \hline
retnolaras & 2016-02-15 & Merge pull request \#16 from igalna/master \\ \hline
rosiengo & 2016-02-15 & NEW POLICY \\ \hline
rosiengo & 2016-02-15 & ADD COMMENTS FOR USAGE GUIDELINES \\ \hline
retnolaras & 2016-02-15 & Merge pull request \#17 from rosiengo/master \\ \hline
Daniel Mendoza & 2016-02-16 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-02-16 & Amended Package structure \\ \hline
retnolaras & 2016-02-18 & move some class \\ \hline
Daniel Mendoza & 2016-02-18 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-02-19 & Test cases for Roads \\ \hline
igalna & 2016-02-19 & Tests for Road \\ \hline
igalna & 2016-02-19 & LaneSection \\ \hline
igalna & 2016-02-19 & RoadFactory \\ \hline
igalna & 2016-02-19 & Implementation of a Road \\ \hline
igalna & 2016-02-19 & Vehicle implementation with a concrete instead of Abstract Vehicle \\ \hline
igalna & 2016-02-19 & Merge remote-tracking branch `upstream/master' \\ \hline
retnolaras & 2016-02-19 & Merge pull request \#18 from igalna/master \\ \hline
Daniel Mendoza & 2016-02-20 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-02-21 & Synchronization and test cases. \\ \hline
AbdoHassan1994 & 2016-02-21 & Merge pull request \#2 from AbdoHassan1994/files \\ \hline
Daniel Mendoza & 2016-02-21 & Moving file into another package. \\ \hline
retnolaras & 2016-02-21 & vehicle factory \\ \hline
Daniel Mendoza & 2016-02-21 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-02-21 & Merge pull request \#19 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-02-21 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-02-21 & VehicleType \\ \hline
Daniel Mendoza & 2016-02-21 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-02-21 & change Road to Lane \\ \hline
Daniel Mendoza & 2016-02-21 & Indentation changes. Implementing Singleton Pattern. \\ \hline
Daniel Mendoza & 2016-02-21 & Lane Factory \\ \hline
Daniel Mendoza & 2016-02-21 & Simulator Engine \\ \hline
Daniel Mendoza & 2016-02-21 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
rosiengo & 2016-02-22 & Merge pull request \#1 from retnolaras/master \\ \hline
rosiengo & 2016-02-22 & update policy code and test \\ \hline
retnolaras & 2016-02-22 & Merge pull request \#20 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
rosiengo & 2016-02-22 & test \\ \hline
retnolaras & 2016-02-22 & Merge pull request \#23 from AbdoHassan1994/master \\ \hline
AbdoHassan1994 & 2016-02-22 & Added initial Code for GUI component. \\ \hline
retnolaras & 2016-02-22 & Merge pull request \#24 from AbdoHassan1994/master \\ \hline
Daniel Mendoza & 2016-02-22 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
AbdoHassan1994 & 2016-02-22 & add files in right location \\ \hline
retnolaras & 2016-02-22 & Merge pull request \#25 from AbdoHassan1994/master \\ \hline
Daniel Mendoza & 2016-02-22 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-02-22 & master \\ \hline
rosiengo & 2016-02-22 & Revert ``update policy code and test'' \\ \hline
rosiengo & 2016-02-22 & Revert ``test'' \\ \hline
rosiengo & 2016-02-22 & policy \\ \hline
retnolaras & 2016-02-22 & Policy Test and changes on policy.java and speed limit.java \\ \hline
retnolaras & 2016-02-22 & add VehicleTest \\ \hline
rosiengo & 2016-02-23 & updated policy \\ \hline
rosiengo & 2016-02-23 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
Daniel Mendoza & 2016-02-24 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-02-24 & Merge pull request \#28 from rosiengo/master \\ \hline
AbdoHassan1994 & 2016-02-25 & update draw function \\ \hline
AbdoHassan1994 & 2016-02-25 & Modified UI component \\ \hline
rosiengo & 2016-02-25 & fixed error \\ \hline
rosiengo & 2016-02-25 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
rosiengo & 2016-02-25 & bugs \\ \hline
igalna & 2016-02-25 & Added a TestSuite class for all the Test classes from sprint 1. \\ \hline
igalna & 2016-02-25 & Merge remote-tracking branch `upstream/master' \\ \hline
retnolaras & 2016-02-25 & Merge pull request \#29 from rosiengo/master \\ \hline
igalna & 2016-02-26 & Merge remote-tracking branch `upstream/master' \\ \hline
rosiengo & 2016-02-26 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
retnolaras & 2016-02-28 & change name trafficLight to trafficLightPolicy \\ \hline
retnolaras & 2016-02-28 & resolve conflict \\ \hline
retnolaras & 2016-02-28 & add TrafficLightSection \\ \hline
rosiengo & 2016-02-29 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
Daniel Mendoza & 2016-02-29 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-02-29 & Merge remote-tracking branch `upstream/master' \\ \hline
retnolaras & 2016-03-01 & encapsulate axom \\ \hline
igalna & 2016-03-01 & Merge remote-tracking branch `upstream/master' \\ \hline
igalna & 2016-03-01 & Commit of updated ListOfListsRoadImpl \\ \hline
retnolaras & 2016-03-01 & Merge pull request \#30 from AbdoHassan1994/master \\ \hline
igalna & 2016-03-01 & Added Test class for the Junction \\ \hline
retnolaras & 2016-03-01 & update vehicle \\ \hline
igalna & 2016-03-01 & Added getVehicle method to AbstractLaneSection \\ \hline
retnolaras & 2016-03-01 & public \\ \hline
rosiengo & 2016-03-01 & GUI \\ \hline
rosiengo & 2016-03-01 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
igalna & 2016-03-01 & Edited ListOfListsRoadImpl to change name of setStartCoordinate \\ \hline
rosiengo & 2016-03-01 & gui \\ \hline
rosiengo & 2016-03-01 & Revert ``GUI'' \\ \hline
rosiengo & 2016-03-01 & Revert ``Revert''GUI``'' \\ \hline
rosiengo & 2016-03-01 & Revert ``Revert''Revert ``GUI''``'' \\ \hline
igalna & 2016-03-01 & Implementation of PrePlannedRouteJunction \\ \hline
igalna & 2016-03-01 & Merge remote-tracking branch `upstream/master' \\ \hline
rosiengo & 2016-03-01 & gui \\ \hline
retnolaras & 2016-03-01 & Merge pull request \#31 from igalna/master \\ \hline
retnolaras & 2016-03-01 & Merge pull request \#32 from rosiengo/master \\ \hline
rosiengo & 2016-03-01 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
retnolaras & 2016-03-01 & TrafficLightJunction \\ \hline
AbdoHassan1994 & 2016-03-03 & Update Car.java \\ \hline
rosiengo & 2016-03-03 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
retnolaras & 2016-03-03 & Merge pull request \#33 from AbdoHassan1994/patch-3 \\ \hline
AbdoHassan1994 & 2016-03-03 & CarPosition \\ \hline
AbdoHassan1994 & 2016-03-03 & Update Position.java \\ \hline
retnolaras & 2016-03-03 & Merge pull request \#34 from AbdoHassan1994/master \\ \hline
AbdoHassan1994 & 2016-03-03 & Update position \\ \hline
Daniel Mendoza & 2016-03-03 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-03 & Context and IContext commit \\ \hline
rosiengo & 2016-03-03 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
retnolaras & 2016-03-03 & Merge pull request \#35 from AbdoHassan1994/master \\ \hline
rosiengo & 2016-03-04 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
retnolaras & 2016-03-04 & Merge pull request \#36 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-04 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-04 & move traffic light to junction \\ \hline
Daniel Mendoza & 2016-03-04 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-04 & fixing syntax errors \\ \hline
Daniel Mendoza & 2016-03-04 & Fixing syntax errors \\ \hline
AbdoHassan1994 & 2016-03-04 & add relative position ( interms of lane , roadsection and road ) to the car \\ \hline
retnolaras & 2016-03-04 & Merge pull request \#37 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-04 & Merge pull request \#38 from AbdoHassan1994/patch-4 \\ \hline
Daniel Mendoza & 2016-03-04 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-04 & move method \\ \hline
retnolaras & 2016-03-04 & Merge pull request \#39 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-04 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
AbdoHassan1994 & 2016-03-04 & add functionality \\ \hline
retnolaras & 2016-03-04 & Merge pull request \#41 from AbdoHassan1994/patch-5 \\ \hline
Daniel Mendoza & 2016-03-05 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
rosiengo & 2016-03-05 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
AbdoHassan1994 & 2016-03-05 & Add LookAhead function \\ \hline
retnolaras & 2016-03-05 & Merge pull request \#43 from AbdoHassan1994/patch-6 \\ \hline
retnolaras & 2016-03-05 & edit errors + typos \\ \hline
AbdoHassan1994 & 2016-03-05 & Change LookAhead Impl \\ \hline
retnolaras & 2016-03-06 & Merge pull request \#44 from AbdoHassan1994/patch-7 \\ \hline
AbdoHassan1994 & 2016-03-06 & Update SimulatorEngine.java \\ \hline
retnolaras & 2016-03-06 & Merge pull request \#45 from AbdoHassan1994/patch-8 \\ \hline
rosiengo & 2016-03-06 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
rosiengo & 2016-03-06 & gui \\ \hline
rosiengo & 2016-03-06 & delete unused gui files \\ \hline
rosiengo & 2016-03-06 & gui \\ \hline
AbdoHassan1994 & 2016-03-06 & Update SimulatorEngine.java \\ \hline
retnolaras & 2016-03-06 & Merge pull request \#46 from rosiengo/master \\ \hline
retnolaras & 2016-03-06 & Merge pull request \#47 from AbdoHassan1994/patch-9 \\ \hline
AbdoHassan1994 & 2016-03-06 & update \\ \hline
AbdoHassan1994 & 2016-03-06 & update Driver program \\ \hline
retnolaras & 2016-03-06 & Merge pull request \#48 from AbdoHassan1994/patch-10 \\ \hline
retnolaras & 2016-03-06 & Merge pull request \#49 from AbdoHassan1994/patch-11 \\ \hline
rosiengo & 2016-03-07 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
retnolaras & 2016-03-07 & Merge pull request \#51 from rosiengo/master \\ \hline
rosiengo & 2016-03-07 & integration \\ \hline
retnolaras & 2016-03-07 & Merge pull request \#52 from rosiengo/master \\ \hline
AbdoHassan1994 & 2016-03-07 & Update SimulatorEngine.java \\ \hline
retnolaras & 2016-03-07 & Merge pull request \#53 from AbdoHassan1994/patch-13 \\ \hline
Daniel Mendoza & 2016-03-07 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-07 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-07 & update TrafficLight junction \\ \hline
retnolaras & 2016-03-07 & edit policy \\ \hline
Daniel Mendoza & 2016-03-07 & promoting Abdo's changes \\ \hline
rosiengo & 2016-03-07 & gui + constants \\ \hline
retnolaras & 2016-03-07 & Merge pull request \#54 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-07 & Merge pull request \#55 from rosiengo/master \\ \hline
rosiengo & 2016-03-07 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
Daniel Mendoza & 2016-03-07 & adding getContext method to engine \\ \hline
retnolaras & 2016-03-07 & Merge pull request \#56 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-07 & Merge pull request \#57 from rosiengo/master \\ \hline
retnolaras & 2016-03-07 & get context \\ \hline
Daniel Mendoza & 2016-03-07 & adding setRenderer \\ \hline
retnolaras & 2016-03-07 & Merge pull request \#58 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-07 & InitScreen changes \\ \hline
rosiengo & 2016-03-07 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
retnolaras & 2016-03-07 & Merge pull request \#59 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-07 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
rosiengo & 2016-03-07 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
rosiengo & 2016-03-07 & updated simulation renderer \\ \hline
retnolaras & 2016-03-07 & Merge pull request \#60 from rosiengo/master \\ \hline
AbdoHassan1994 & 2016-03-07 & fixed errors \\ \hline
AbdoHassan1994 & 2016-03-07 & correct position vairable \\ \hline
AbdoHassan1994 & 2016-03-07 & fix car ID variable passing \\ \hline
retnolaras & 2016-03-07 & Merge pull request \#61 from AbdoHassan1994/patch-14 \\ \hline
retnolaras & 2016-03-07 & Merge pull request \#62 from AbdoHassan1994/patch-15 \\ \hline
retnolaras & 2016-03-07 & Merge pull request \#63 from AbdoHassan1994/patch-16 \\ \hline
Daniel Mendoza & 2016-03-08 & set start coordinate at 35 \\ \hline
Daniel Mendoza & 2016-03-08 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-08 & Merge pull request \#64 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-08 & adding my change \\ \hline
Daniel Mendoza & 2016-03-08 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-08 & update TrafficLight junction \\ \hline
igalna & 2016-03-08 & PrePlannedRouteJunction generateSectionsOfJunction() method \\ \hline
Daniel Mendoza & 2016-03-08 & moving car \\ \hline
rosiengo & 2016-03-08 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
retnolaras & 2016-03-08 & Merge pull request \#65 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-08 & Merge remote-tracking branch `upstream/master' \\ \hline
Daniel Mendoza & 2016-03-08 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
rosiengo & 2016-03-08 & Revert ``updated simulation renderer'' \\ \hline
retnolaras & 2016-03-08 & Merge pull request \#67 from rosiengo/master \\ \hline
rosiengo & 2016-03-08 & render \\ \hline
rosiengo & 2016-03-08 & Revert ``render'' \\ \hline
AbdoHassan1994 & 2016-03-08 & Update SimulatorEngine.java \\ \hline
retnolaras & 2016-03-08 & Merge pull request \#68 from AbdoHassan1994/patch-17 \\ \hline
rosiengo & 2016-03-08 & Merge branch `master' of https://github.com/retnolaras/Traffic \\ \hline
igalna & 2016-03-08 & TestJunction buildJunctionWithInputWidthOneOutputWidthTwo() \\ \hline
igalna & 2016-03-08 & TestJunction buildJunctionWithInputWidthTwoOutputWidthOne() \\ \hline
igalna & 2016-03-08 & PrePlannedRouteJunction \\ \hline
igalna & 2016-03-08 & buildJunctionSections(int) \\ \hline
AbdoHassan1994 & 2016-03-09 & Update SimulatorEngine.java \\ \hline
Daniel Mendoza & 2016-03-09 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-09 & Merge pull request \#69 from AbdoHassan1994/patch-18 \\ \hline
Daniel Mendoza & 2016-03-09 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-10 & Tests for the createMappings() method of PrePlannedRouteJunction \\ \hline
igalna & 2016-03-10 & PrePlannedRouteJunction \\ \hline
igalna & 2016-03-10 & Merge remote-tracking branch `upstream/master' \\ \hline
igalna & 2016-03-10 & TestJunction test multiple inputs and outputs \\ \hline
igalna & 2016-03-10 & generateSectionsOfJunction() \\ \hline
igalna & 2016-03-11 & PrePLannedRouteJunction class \\ \hline
retnolaras & 2016-03-11 & Merge pull request \#70 from igalna/master \\ \hline
Daniel Mendoza & 2016-03-11 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
rosiengo & 2016-03-12 & Merge branch `master' of https://github.com/retnolaras/Traffic \\ \hline
rosiengo & 2016-03-14 & GUI- settings validation \\ \hline
retnolaras & 2016-03-14 & Merge pull request \#71 from rosiengo/master \\ \hline
Daniel Mendoza & 2016-03-14 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
rosiengo & 2016-03-14 & generate Maps \\ \hline
Daniel Mendoza & 2016-03-14 & adding getJunctionpoints to be used by the UI to draw junctions. \\ \hline
Daniel Mendoza & 2016-03-14 & getTrafficLights \\ \hline
retnolaras & 2016-03-14 & Merge pull request \#72 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-14 & PrePlannedRoute Junction \\ \hline
igalna & 2016-03-14 & Merge remote-tracking branch `upstream/master' \\ \hline
Daniel Mendoza & 2016-03-14 & Adding Orientation \\ \hline
retnolaras & 2016-03-14 & Merge pull request \#73 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-14 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
AbdoHassan1994 & 2016-03-14 & Update SimulatorEngine.java \\ \hline
retnolaras & 2016-03-14 & Merge pull request \#74 from AbdoHassan1994/patch-19 \\ \hline
rosiengo & 2016-03-15 & dc \\ \hline
rosiengo & 2016-03-15 & Revert ``generate Maps'' \\ \hline
rosiengo & 2016-03-15 & Revert ``Revert''generate Maps``'' \\ \hline
rosiengo & 2016-03-15 & Revert ``Revert''Revert ``generate Maps''``'' \\ \hline
rosiengo & 2016-03-15 & map \\ \hline
retnolaras & 2016-03-15 & Merge pull request \#75 from rosiengo/master \\ \hline
Daniel Mendoza & 2016-03-15 & preliminary modification to support moving through junctions \\ \hline
retnolaras & 2016-03-15 & change TrafficLight Colour \\ \hline
retnolaras & 2016-03-15 & update initscreen \\ \hline
rosiengo & 2016-03-15 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
retnolaras & 2016-03-15 & change context \\ \hline
retnolaras & 2016-03-15 & add getorientation \\ \hline
retnolaras & 2016-03-15 & Merge pull request \#76 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-15 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-15 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-15 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-15 & Merge pull request \#77 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
rosiengo & 2016-03-15 & Merge branch `master' of https://github.com/retnolaras/Traffic \\ \hline
AbdoHassan1994 & 2016-03-15 & Update SimulatorEngine.java \\ \hline
rosiengo & 2016-03-15 & updated Map \\ \hline
retnolaras & 2016-03-15 & Merge pull request \#79 from rosiengo/master \\ \hline
retnolaras & 2016-03-15 & Merge pull request \#78 from AbdoHassan1994/patch-20 \\ \hline
Daniel Mendoza & 2016-03-15 & adding stop simulation \\ \hline
retnolaras & 2016-03-15 & edit simulation engine \\ \hline
retnolaras & 2016-03-15 & Merge pull request \#80 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-15 & Terminate button function \\ \hline
Daniel Mendoza & 2016-03-15 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
AbdoHassan1994 & 2016-03-15 & Update Vehicle.java \\ \hline
retnolaras & 2016-03-15 & Merge pull request \#81 from AbdoHassan1994/patch-21 \\ \hline
AbdoHassan1994 & 2016-03-15 & add support for junctions, maps \\ \hline
retnolaras & 2016-03-15 & Merge pull request \#82 from AbdoHassan1994/patch-22 \\ \hline
rosiengo & 2016-03-16 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
igalna & 2016-03-16 & Commit \\ \hline
igalna & 2016-03-16 & commit of PrePlannedRouteJunction produceRouteMethod() \\ \hline
igalna & 2016-03-16 & Commit of javaDoc for tests and PrePlannedRouteJunction \\ \hline
igalna & 2016-03-16 & This commit is to even up the example diagram \\ \hline
igalna & 2016-03-16 & Diagram \\ \hline
igalna & 2016-03-16 & More Drawings \\ \hline
igalna & 2016-03-16 & Merge remote-tracking branch `upstream/master' \\ \hline
Daniel Mendoza & 2016-03-16 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-16 & Merge pull request \#83 from igalna/master \\ \hline
Daniel Mendoza & 2016-03-16 & fixing issues \\ \hline
retnolaras & 2016-03-16 & Merge pull request \#84 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-16 & JavaDoc for TestSingleLaneFourEntryFourExitOverlappingJunction \\ \hline
igalna & 2016-03-16 & Testing SingleLaneFourEntryFourExit \\ \hline
igalna & 2016-03-16 & Updated TestSuite to include TestSingleLaneThreeEntryThreeExitOverLappingJunction \\ \hline
rosiengo & 2016-03-16 & map and gui \\ \hline
rosiengo & 2016-03-16 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
AbdoHassan1994 & 2016-03-16 & correct car behaviour \\ \hline
retnolaras & 2016-03-16 & Merge pull request \#85 from AbdoHassan1994/patch-23 \\ \hline
AbdoHassan1994 & 2016-03-16 & Update Vehicle.java \\ \hline
Daniel Mendoza & 2016-03-16 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-16 & Merge pull request \#86 from AbdoHassan1994/patch-24 \\ \hline
rosiengo & 2016-03-16 & map + simulation \\ \hline
rosiengo & 2016-03-16 & map- traffic light and junctions \\ \hline
retnolaras & 2016-03-16 & Merge pull request \#87 from rosiengo/master \\ \hline
rosiengo & 2016-03-17 & traffic light control \\ \hline
retnolaras & 2016-03-17 & Merge pull request \#88 from rosiengo/master \\ \hline
igalna & 2016-03-17 & Merge remote-tracking branch `upstream/master' \\ \hline
Daniel Mendoza & 2016-03-17 & Engine \\ \hline
retnolaras & 2016-03-17 & edit Position.java \\ \hline
retnolaras & 2016-03-17 & Map1.java \\ \hline
Daniel Mendoza & 2016-03-17 & Revert ``Engine'' \\ \hline
Daniel Mendoza & 2016-03-17 & Merge pull request \#89 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-17 & context changes \\ \hline
Daniel Mendoza & 2016-03-17 & Merge pull request \#90 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-17 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-17 & Test for three lane Junction \\ \hline
igalna & 2016-03-17 & Merge remote-tracking branch `upstream/master' \\ \hline
rosiengo & 2016-03-18 & add junctionCooridates \\ \hline
rosiengo & 2016-03-18 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
rosiengo & 2016-03-18 & getTrafficLight at Junction \\ \hline
rosiengo & 2016-03-18 & update engine to get junctions and trafficlights from map \\ \hline
rosiengo & 2016-03-18 & activate trafficlights in simulation engine \\ \hline
retnolaras & 2016-03-18 & Merge pull request \#91 from rosiengo/master \\ \hline
Daniel Mendoza & 2016-03-18 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
rosiengo & 2016-03-18 & Merge branch `master' of https://github.com/retnolaras/Traffic \\ \hline
Daniel Mendoza & 2016-03-18 & Indentation and name variable change to be meaningful. \\ \hline
Daniel Mendoza & 2016-03-18 & Merge pull request \#92 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-18 & Merge remote-tracking branch `upstream/master' \\ \hline
Daniel Mendoza & 2016-03-18 & Für Abdo \\ \hline
Daniel Mendoza & 2016-03-18 & Merge pull request \#93 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-18 & update engine and position \\ \hline
igalna & 2016-03-18 & Merge remote-tracking branch `upstream/master' \\ \hline
retnolaras & 2016-03-18 & PERFORMED LOOKAHEAD CORRECTLT \\ \hline
Daniel Mendoza & 2016-03-18 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-18 & adding constructors and get junction points coordinates \\ \hline
Daniel Mendoza & 2016-03-18 & Merge pull request \#94 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-18 & moving correclty \\ \hline
Daniel Mendoza & 2016-03-18 & Merge pull request \#95 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-18 & Merge remote-tracking branch `upstream/master' \\ \hline
rosiengo & 2016-03-18 & junction + test junction \\ \hline
retnolaras & 2016-03-18 & new \\ \hline
Daniel Mendoza & 2016-03-19 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-19 & moving in a junction \\ \hline
Daniel Mendoza & 2016-03-19 & Merge pull request \#97 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-19 & IContext \\ \hline
Daniel Mendoza & 2016-03-19 & Merge pull request \#98 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-19 & Movement changes \\ \hline
Daniel Mendoza & 2016-03-19 & Merge pull request \#99 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-19 & simulationData \\ \hline
retnolaras & 2016-03-19 & edit SimulationData.java \\ \hline
rosiengo & 2016-03-19 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
rosiengo & 2016-03-19 & Merge branch `master' of https://github.com/retnolaras/Traffic \\ \hline
rosiengo & 2016-03-20 & final map + activate trafficlight \\ \hline
retnolaras & 2016-03-20 & Merge pull request \#100 from rosiengo/master \\ \hline
Daniel Mendoza & 2016-03-20 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
rosiengo & 2016-03-20 & RANDOM EXIT POINT AT JUNCTION \\ \hline
retnolaras & 2016-03-20 & Merge pull request \#101 from rosiengo/master \\ \hline
rosiengo & 2016-03-20 & fix random range \\ \hline
rosiengo & 2016-03-20 & Merge branch `master' of https://github.com/retnolaras/Traffic \\ \hline
Daniel Mendoza & 2016-03-20 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
AbdoHassan1994 & 2016-03-20 & update interface \\ \hline
AbdoHassan1994 & 2016-03-20 & Update ListOfListsRoadImpl.java \\ \hline
retnolaras & 2016-03-20 & Merge pull request \#102 from rosiengo/master \\ \hline
retnolaras & 2016-03-20 & Merge pull request \#103 from AbdoHassan1994/patch-26 \\ \hline
retnolaras & 2016-03-20 & Merge pull request \#104 from AbdoHassan1994/patch-27 \\ \hline
AbdoHassan1994 & 2016-03-20 & Update SimulatorEngine.java \\ \hline
retnolaras & 2016-03-20 & Merge pull request \#105 from AbdoHassan1994/patch-28 \\ \hline
Daniel Mendoza & 2016-03-20 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-21 & Merge remote-tracking branch `upstream/master' \\ \hline
Daniel Mendoza & 2016-03-21 & Adding index \\ \hline
retnolaras & 2016-03-21 & Merge pull request \#106 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-21 & Merge remote-tracking branch `upstream/master' \\ \hline
rosiengo & 2016-03-21 & update junction draw \\ \hline
retnolaras & 2016-03-21 & Merge pull request \#107 from rosiengo/master \\ \hline
igalna & 2016-03-21 & Merge remote-tracking branch `upstream/master' \\ \hline
AbdoHassan1994 & 2016-03-21 & Update Vehicle.java \\ \hline
retnolaras & 2016-03-21 & Merge pull request \#108 from AbdoHassan1994/patch-29 \\ \hline
AbdoHassan1994 & 2016-03-21 & Update SimulatorEngine.java \\ \hline
igalna & 2016-03-21 & Merge remote-tracking branch `upstream/master' \\ \hline
igalna & 2016-03-21 & Commit of Test Suite \\ \hline
igalna & 2016-03-21 & Final report for Traffic simulator \\ \hline
igalna & 2016-03-21 & Commit of final report folder \\ \hline
AbdoHassan1994 & 2016-03-21 & Update Map1.java \\ \hline
retnolaras & 2016-03-21 & Merge pull request \#110 from igalna/master \\ \hline
retnolaras & 2016-03-21 & Merge pull request \#109 from AbdoHassan1994/patch-30 \\ \hline
retnolaras & 2016-03-21 & Merge pull request \#111 from AbdoHassan1994/patch-31 \\ \hline
Daniel Mendoza & 2016-03-21 & Pause, resume, increase, decrease actions. \\ \hline
Daniel Mendoza & 2016-03-21 & Merge pull request \#112 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
AbdoHassan1994 & 2016-03-21 & Update SimulatorEngine.java \\ \hline
AbdoHassan1994 & 2016-03-21 & Update Vehicle.java \\ \hline
AbdoHassan1994 & 2016-03-21 & Update Junction.java \\ \hline
AbdoHassan1994 & 2016-03-21 & Update PrePlannedRouteJunction.java \\ \hline
AbdoHassan1994 & 2016-03-21 & Update ListOfListsRoadImpl.java \\ \hline
retnolaras & 2016-03-21 & Merge pull request \#117 from AbdoHassan1994/patch-36 \\ \hline
retnolaras & 2016-03-21 & Merge pull request \#116 from AbdoHassan1994/patch-35 \\ \hline
retnolaras & 2016-03-21 & Merge pull request \#115 from AbdoHassan1994/patch-34 \\ \hline
retnolaras & 2016-03-21 & Merge pull request \#114 from AbdoHassan1994/patch-33 \\ \hline
retnolaras & 2016-03-21 & Merge pull request \#113 from AbdoHassan1994/patch-32 \\ \hline
Daniel Mendoza & 2016-03-21 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
AbdoHassan1994 & 2016-03-22 & Update SimulatorEngine.java \\ \hline
Daniel Mendoza & 2016-03-22 & Merge pull request \#118 from AbdoHassan1994/patch-37 \\ \hline
AbdoHassan1994 & 2016-03-22 & Update Vehicle.java \\ \hline
AbdoHassan1994 & 2016-03-22 & Update ListOfListsRoadImpl.java \\ \hline
AbdoHassan1994 & 2016-03-22 & Update Map1.java \\ \hline
Daniel Mendoza & 2016-03-22 & Merge pull request \#119 from AbdoHassan1994/patch-38 \\ \hline
Daniel Mendoza & 2016-03-22 & Merge pull request \#120 from AbdoHassan1994/patch-39 \\ \hline
Daniel Mendoza & 2016-03-22 & Merge pull request \#121 from AbdoHassan1994/patch-40 \\ \hline
AbdoHassan1994 & 2016-03-22 & Update Road.java \\ \hline
Daniel Mendoza & 2016-03-22 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-22 & Merge pull request \#122 from AbdoHassan1994/patch-41 \\ \hline
Daniel Mendoza & 2016-03-22 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-22 & update simulationData \\ \hline
AbdoHassan1994 & 2016-03-22 & Update PrePlannedRouteJunction.java \\ \hline
AbdoHassan1994 & 2016-03-22 & Update SimulatorEngine.java \\ \hline
AbdoHassan1994 & 2016-03-22 & Update Map1.java \\ \hline
Daniel Mendoza & 2016-03-22 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-22 & Adding Future work section as well as additions to the Bibliography \\ \hline
igalna & 2016-03-22 & Merge remote-tracking branch `upstream/master' \\ \hline
retnolaras & 2016-03-22 & Merge pull request \#123 from AbdoHassan1994/patch-42 \\ \hline
retnolaras & 2016-03-22 & Merge pull request \#124 from AbdoHassan1994/patch-43 \\ \hline
retnolaras & 2016-03-22 & Merge pull request \#125 from AbdoHassan1994/patch-44 \\ \hline
Daniel Mendoza & 2016-03-22 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
AbdoHassan1994 & 2016-03-22 & Update SimulatorEngine.java \\ \hline
AbdoHassan1994 & 2016-03-22 & Update Position.java \\ \hline
igalna & 2016-03-22 & Merge remote-tracking branch `upstream/master' \\ \hline
Daniel Mendoza & 2016-03-22 & Merge pull request \#126 from AbdoHassan1994/patch-46 \\ \hline
Daniel Mendoza & 2016-03-22 & Merge pull request \#127 from AbdoHassan1994/patch-45 \\ \hline
Daniel Mendoza & 2016-03-22 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-22 & Merge remote-tracking branch `upstream/master' \\ \hline
igalna & 2016-03-22 & Final Report Future work, paralellisation \\ \hline
Daniel Mendoza & 2016-03-22 & Moving cars \\ \hline
Daniel Mendoza & 2016-03-22 & Merge pull request \#128 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-22 & Final report, future work, external libraries \\ \hline
igalna & 2016-03-22 & Merge remote-tracking branch `upstream/master' \\ \hline
retnolaras & 2016-03-22 & Merge pull request \#129 from igalna/master \\ \hline
Daniel Mendoza & 2016-03-22 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-23 & Continuing work on the Future work section \\ \hline
igalna & 2016-03-23 & Future work, agent programming for vehicle behaviour \\ \hline
rosiengo & 2016-03-23 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
rosiengo & 2016-03-23 & Merge branch `master' of https://github.com/retnolaras/Traffic \\ \hline
rosiengo & 2016-03-23 & put vehicle at the middle of the lane \\ \hline
rosiengo & 2016-03-23 & update policy with only 1 speed limit setting \\ \hline
retnolaras & 2016-03-23 & Merge pull request \#130 from rosiengo/master \\ \hline
rosiengo & 2016-03-23 & get user settings from GUI in simulation engine \\ \hline
rosiengo & 2016-03-23 & Merge branch `master' of https://github.com/retnolaras/Traffic \\ \hline
Daniel Mendoza & 2016-03-23 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
rosiengo & 2016-03-23 & add report pane to GUI and user-defined traffic density to simulation engine \\ \hline
rosiengo & 2016-03-23 & reset report one starting another simulation session \\ \hline
retnolaras & 2016-03-23 & Merge pull request \#131 from rosiengo/master \\ \hline
rosiengo & 2016-03-23 & Merge remote-tracking branch `refs/remotes/retnolaras/master' \\ \hline
Daniel Mendoza & 2016-03-23 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-23 & Solving blinking cars \\ \hline
Daniel Mendoza & 2016-03-23 & Merge pull request \#132 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-24 & Merge remote-tracking branch `upstream/master' \\ \hline
retnolaras & 2016-03-24 & latex-git-log \\ \hline
igalna & 2016-03-24 & Future work, Machine Learning \\ \hline
AbdoHassan1994 & 2016-03-24 & correct definition of junctions \\ \hline
igalna & 2016-03-24 & Final Report, future work, user defined maps and third part maps \\ \hline
Daniel Mendoza & 2016-03-24 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
rosiengo & 2016-03-24 & Merge branch `master' of https://github.com/retnolaras/Traffic \\ \hline
retnolaras & 2016-03-24 & Merge pull request \#133 from AbdoHassan1994/patch-47 \\ \hline
retnolaras & 2016-03-24 & update SimulationData \\ \hline
rosiengo & 2016-03-24 & Map2- simple map \\ \hline
rosiengo & 2016-03-24 & Map options \\ \hline
retnolaras & 2016-03-24 & move the updateReport \\ \hline
retnolaras & 2016-03-24 & update simulationEngine \\ \hline
retnolaras & 2016-03-24 & merge \\ \hline
retnolaras & 2016-03-24 & Merge branch `master' into pr/134 \\ \hline
Daniel Mendoza & 2016-03-25 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-25 & update \\ \hline
retnolaras & 2016-03-25 & Merge branch `master' into pr/134 \\ \hline
retnolaras & 2016-03-25 & Merge pull request \#135 from retnolaras/pr/134 \\ \hline
retnolaras & 2016-03-25 & removing error \\ \hline
Daniel Mendoza & 2016-03-25 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-25 & Solve Terminate button bug \\ \hline
Daniel Mendoza & 2016-03-25 & Merge pull request \#136 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-25 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-25 & update report \\ \hline
AbdoHassan1994 & 2016-03-25 & Update SimulatorEngine.java \\ \hline
retnolaras & 2016-03-25 & edit estimation calculation \\ \hline
retnolaras & 2016-03-25 & Merge pull request \#137 from AbdoHassan1994/patch-49 \\ \hline
retnolaras & 2016-03-25 & SimulationEngine \\ \hline
Daniel Mendoza & 2016-03-25 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-25 & Merging changes: Traffic light + Simulation Data \\ \hline
Daniel Mendoza & 2016-03-25 & Merge pull request \#138 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-25 & Disable/enable buttons when starting/stopping sessions. \\ \hline
Daniel Mendoza & 2016-03-25 & Merge pull request \#139 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-25 & Fix for switch between maps \\ \hline
Daniel Mendoza & 2016-03-25 & Merge pull request \#140 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-26 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-27 & Stopping simulation when closing the window \\ \hline
Daniel Mendoza & 2016-03-27 & Merge pull request \#141 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-27 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-27 & Implementing different behaviours in vehicles \\ \hline
Daniel Mendoza & 2016-03-27 & Merge pull request \#142 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-27 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-27 & Colours for vehicles. \\ \hline
Daniel Mendoza & 2016-03-27 & Merge pull request \#143 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-27 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-27 & Simulation data change \\ \hline
AbdoHassan1994 & 2016-03-28 & Update SimulatorEngine.java \\ \hline
AbdoHassan1994 & 2016-03-28 & Update Vehicle.java \\ \hline
Daniel Mendoza & 2016-03-28 & Merge pull request \#144 from AbdoHassan1994/patch-51 \\ \hline
Daniel Mendoza & 2016-03-28 & Merge pull request \#145 from AbdoHassan1994/patch-50 \\ \hline
Daniel Mendoza & 2016-03-28 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-28 & Commenting out lines in order to remove build errors \\ \hline
Daniel Mendoza & 2016-03-28 & Merge pull request \#146 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-28 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-28 & If the iteration reaches the session duration limit the session is paused automatically. \\ \hline
Daniel Mendoza & 2016-03-28 & Merge pull request \#147 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-28 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
AbdoHassan1994 & 2016-03-28 & Update SimulatorEngine.java \\ \hline
AbdoHassan1994 & 2016-03-28 & Update InitScreen.java \\ \hline
AbdoHassan1994 & 2016-03-28 & Update GUIComponents.java \\ \hline
AbdoHassan1994 & 2016-03-28 & Update SimulationSettings.java \\ \hline
igalna & 2016-03-28 & Merge remote-tracking branch `upstream/master' \\ \hline
igalna & 2016-03-28 & Evaiuation, Lessons learned and challenges \\ \hline
Daniel Mendoza & 2016-03-28 & Merge pull request \#148 from AbdoHassan1994/patch-55 \\ \hline
Daniel Mendoza & 2016-03-28 & Merge pull request \#149 from AbdoHassan1994/patch-54 \\ \hline
Daniel Mendoza & 2016-03-28 & Merge pull request \#150 from AbdoHassan1994/patch-53 \\ \hline
Daniel Mendoza & 2016-03-28 & Merge pull request \#151 from AbdoHassan1994/patch-52 \\ \hline
Daniel Mendoza & 2016-03-28 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-28 & adapt the simulationData to the new simulationEngine \\ \hline
Daniel Mendoza & 2016-03-28 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-28 & GUIComponent update \\ \hline
igalna & 2016-03-28 & Final Report, Evaluation, Lessons learned and challenges, Overreach \\ \hline
igalna & 2016-03-28 & Merge remote-tracking branch `upstream/master' \\ \hline
Daniel Mendoza & 2016-03-28 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-29 & Final Project, Evaluation, Lessons Learned, Overreach \\ \hline
igalna & 2016-03-29 & Final Report, Evaluation, Lessons Learned, Vagueness of Specification \\ \hline
igalna & 2016-03-29 & Final Report, Evaluation, Lessons Learned, Principles of Software Engineering \\ \hline
igalna & 2016-03-29 & Final report, Evaluation, Lessons learned, software principles \\ \hline
retnolaras & 2016-03-29 & update report \\ \hline
Daniel Mendoza & 2016-03-29 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-29 & Change average speed to km/h, covert it \\ \hline
Daniel Mendoza & 2016-03-29 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-29 & Adjusting the simulation time to seconds \\ \hline
Daniel Mendoza & 2016-03-29 & Merge pull request \#154 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-29 & reset the report from the Start button \\ \hline
retnolaras & 2016-03-29 & Updates from ShareLaTeX \\ \hline
igalna & 2016-03-29 & Final Report, Evaluation, Lessons Learned, Software Principles \\ \hline
igalna & 2016-03-29 & Merge remote-tracking branch `upstream/master' \\ \hline
retnolaras & 2016-03-29 & Merge pull request \#152 from igalna/master \\ \hline
Daniel Mendoza & 2016-03-29 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-29 & Resolving merge conflict with retno master \\ \hline
igalna & 2016-03-29 & Final Report, Evaluation, Lessons learned, Software Principles \\ \hline
retnolaras & 2016-03-29 & session manager \\ \hline
igalna & 2016-03-29 & Merge conflict with retno \\ \hline
igalna & 2016-03-29 & Merge Conflicts with Retno \\ \hline
retnolaras & 2016-03-29 & change session duration to second \\ \hline
Daniel Mendoza & 2016-03-29 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
igalna & 2016-03-29 & Merge remote-tracking branch `upstream/master' \\ \hline
retnolaras & 2016-03-29 & Merge pull request \#155 from igalna/master \\ \hline
retnolaras & 2016-03-29 & Updates from ShareLaTeX \\ \hline
retnolaras & 2016-03-29 & lesson learned \\ \hline
retnolaras & 2016-03-29 & Updates from ShareLaTeX \\ \hline
retnolaras & 2016-03-29 & Revert ``Merge pull request \#155 from igalna/master'' \\ \hline
retnolaras & 2016-03-29 & Merge pull request \#156 from retnolaras/sharelatex-2016-03-29-1637 \\ \hline
retnolaras & 2016-03-29 & Updates from ShareLaTeX \\ \hline
retnolaras & 2016-03-29 & Merge sharelatex-2016-03-29-1642 into master \\ \hline
retnolaras & 2016-03-29 & Updates from ShareLaTeX \\ \hline
retnolaras & 2016-03-29 & update estimation traffic calculation \\ \hline
retnolaras & 2016-03-30 & Final report, Evaluation, Lessons Learned, Communication \\ \hline
retnolaras & 2016-03-30 & Merge sharelatex-2016-03-30-1156 into master \\ \hline
Daniel Mendoza & 2016-03-30 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
AbdoHassan1994 & 2016-03-30 & Update InitScreen.java \\ \hline
Daniel Mendoza & 2016-03-30 & Merge pull request \#157 from AbdoHassan1994/patch-56 \\ \hline
Daniel Mendoza & 2016-03-30 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
AbdoHassan1994 & 2016-03-30 & Update InitScreen.java \\ \hline
Daniel Mendoza & 2016-03-30 & Merge pull request \#158 from AbdoHassan1994/patch-57 \\ \hline
Daniel Mendoza & 2016-03-30 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-30 & Final Report, Evaluation, Lesson Learned, Team work \\ \hline
retnolaras & 2016-03-30 & Merge sharelatex-2016-03-30-1252 into master \\ \hline
AbdoHassan1994 & 2016-03-30 & Update SimulatorEngine.java \\ \hline
retnolaras & 2016-03-30 & Moved Image files into images folder \\ \hline
retnolaras & 2016-03-30 & Merge pull request \#159 from AbdoHassan1994/patch-58 \\ \hline
retnolaras & 2016-03-30 & add TestSimulationData \\ \hline
Daniel Mendoza & 2016-03-30 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-30 & Cleaning Session Manager code \\ \hline
Daniel Mendoza & 2016-03-30 & Merge pull request \#160 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-30 & update testVehicle and testSimulation \\ \hline
retnolaras & 2016-03-30 & Final Report. using sharlatex team members are working on a variety of different sections. \\ \hline
retnolaras & 2016-03-30 & Merge sharelatex-2016-03-30-1544 into master \\ \hline
Daniel Mendoza & 2016-03-30 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-30 & Junit screenshot \\ \hline
retnolaras & 2016-03-30 & Merge pull request \#161 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-30 & Updates from ShareLaTeX \\ \hline
retnolaras & 2016-03-30 & Merge sharelatex-2016-03-30-1609 into master \\ \hline
Daniel Mendoza & 2016-03-30 & Removing unused UI \\ \hline
Daniel Mendoza & 2016-03-30 & Merge pull request \#162 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-30 & Cleaning code. \\ \hline
retnolaras & 2016-03-30 & Images \\ \hline
retnolaras & 2016-03-30 & recent changes 30/3/16 18:00 \\ \hline
retnolaras & 2016-03-30 & Merge sharelatex-2016-03-30-1702 into master \\ \hline
Daniel Mendoza & 2016-03-30 & Formatting code \\ \hline
Daniel Mendoza & 2016-03-30 & Merge pull request \#163 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-30 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-30 & Merge pull request \#164 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-30 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-30 & Formatting code \\ \hline
Daniel Mendoza & 2016-03-30 & Merge pull request \#165 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-30 & Merge branch `retnolaras/master' into daniel-arturo-mendoza-patch-1 \\ \hline
Daniel Mendoza & 2016-03-30 & Formatting code \\ \hline
Daniel Mendoza & 2016-03-30 & Merge pull request \#166 from daniel-arturo-mendoza/daniel-arturo-mendoza-patch-1 \\ \hline
retnolaras & 2016-03-30 & change step size \\ \hline
retnolaras & 2016-03-30 & edit the image \\ \hline
retnolaras & 2016-03-30 & recent changes 30/3/16 19:00 \\ \hline
retnolaras & 2016-03-30 & Merge sharelatex-2016-03-30-1756 into master \\ \hline
retnolaras & 2016-03-31 & bug fixing \\ \hline
retnolaras & 2016-03-31 & Introduction cleaning up the introduction \\ \hline
retnolaras & 2016-03-31 & Merge sharelatex-2016-03-31-1223 into master \\ \hline

\end{longtabu}
\end{center}


\end{document} %END OF REPORT

